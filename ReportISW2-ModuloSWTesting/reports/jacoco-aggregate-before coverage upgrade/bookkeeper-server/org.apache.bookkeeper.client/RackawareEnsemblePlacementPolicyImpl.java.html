<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RackawareEnsemblePlacementPolicyImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">bookkeeper-server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">RackawareEnsemblePlacementPolicyImpl.java</span></div><h1>RackawareEnsemblePlacementPolicyImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_JOINED;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_LEFT;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER;
import static org.apache.bookkeeper.client.BookKeeperClientStats.CLIENT_SCOPE;
import static org.apache.bookkeeper.client.BookKeeperClientStats.NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK;
import static org.apache.bookkeeper.client.BookKeeperClientStats.READ_REQUESTS_REORDERED;
import static org.apache.bookkeeper.client.RegionAwareEnsemblePlacementPolicy.UNKNOWN_REGION;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;

import io.netty.util.HashedWheelTimer;

import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.Configurable;
import org.apache.bookkeeper.feature.FeatureProvider;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieNode;
import org.apache.bookkeeper.net.DNSToSwitchMapping;
import org.apache.bookkeeper.net.NetworkTopology;
import org.apache.bookkeeper.net.NetworkTopologyImpl;
import org.apache.bookkeeper.net.Node;
import org.apache.bookkeeper.net.NodeBase;
import org.apache.bookkeeper.net.ScriptBasedMapping;
import org.apache.bookkeeper.net.StabilizeNetworkTopology;
import org.apache.bookkeeper.proto.BookieAddressResolver;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.commons.collections4.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple rackware ensemble placement policy.
 *
 * &lt;p&gt;Make most of the class and methods as protected, so it could be extended to implement other algorithms.
 */
@StatsDoc(
    name = CLIENT_SCOPE,
    help = &quot;BookKeeper client stats&quot;
)
public class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {

<span class="nc" id="L86">    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);</span>
    int maxWeightMultiple;

    protected int minNumRacksPerWriteQuorum;
    protected boolean enforceMinNumRacksPerWriteQuorum;
    protected boolean ignoreLocalNodeInPlacementPolicy;

    public static final String REPP_DNS_RESOLVER_CLASS = &quot;reppDnsResolverClass&quot;;
    public static final String REPP_RANDOM_READ_REORDERING = &quot;ensembleRandomReadReordering&quot;;

    static final int RACKNAME_DISTANCE_FROM_LEAVES = 1;

    // masks for reordering
    static final int LOCAL_MASK       = 0x01 &lt;&lt; 24;
    static final int LOCAL_FAIL_MASK  = 0x02 &lt;&lt; 24;
    static final int REMOTE_MASK      = 0x04 &lt;&lt; 24;
    static final int REMOTE_FAIL_MASK = 0x08 &lt;&lt; 24;
    static final int READ_ONLY_MASK   = 0x10 &lt;&lt; 24;
    static final int SLOW_MASK        = 0x20 &lt;&lt; 24;
    static final int UNAVAIL_MASK     = 0x40 &lt;&lt; 24;
    static final int MASK_BITS        = 0xFFF &lt;&lt; 20;

    protected HashedWheelTimer timer;
    // Use a loading cache so slow bookies are expired. Use entryId as values.
    protected Cache&lt;BookieId, Long&gt; slowBookies;
    protected BookieNode localNode;
<span class="nc" id="L112">    protected boolean reorderReadsRandom = false;</span>
<span class="nc" id="L113">    protected boolean enforceDurability = false;</span>
<span class="nc" id="L114">    protected int stabilizePeriodSeconds = 0;</span>
<span class="nc" id="L115">    protected int reorderThresholdPendingRequests = 0;</span>
    // looks like these only assigned in the same thread as constructor, immediately after constructor;
    // no need to make volatile
<span class="nc" id="L118">    protected StatsLogger statsLogger = null;</span>

<span class="nc" id="L120">    @StatsDoc(</span>
            name = READ_REQUESTS_REORDERED,
            help = &quot;The distribution of number of bookies reordered on each read request&quot;
    )
    protected OpStatsLogger readReorderedCounter = null;
<span class="nc" id="L125">    @StatsDoc(</span>
            name = FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER,
            help = &quot;Counter for number of times DNSResolverDecorator failed to resolve Network Location&quot;
    )
    protected Counter failedToResolveNetworkLocationCounter = null;
    @StatsDoc(
            name = NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK,
            help = &quot;Gauge for the number of writable Bookies in default rack&quot;
    )
    protected Gauge&lt;Integer&gt; numWritableBookiesInDefaultRack;

<span class="nc" id="L136">    private String defaultRack = NetworkTopology.DEFAULT_RACK;</span>

    RackawareEnsemblePlacementPolicyImpl() {
<span class="nc" id="L139">        this(false);</span>
<span class="nc" id="L140">    }</span>

<span class="nc" id="L142">    RackawareEnsemblePlacementPolicyImpl(boolean enforceDurability) {</span>
<span class="nc" id="L143">        this.enforceDurability = enforceDurability;</span>
<span class="nc" id="L144">        topology = new NetworkTopologyImpl();</span>
<span class="nc" id="L145">    }</span>

    /**
     * Initialize the policy.
     *
     * @param dnsResolver the object used to resolve addresses to their network address
     * @return initialized ensemble placement policy
     */
    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,
                                                              HashedWheelTimer timer,
                                                              boolean reorderReadsRandom,
                                                              int stabilizePeriodSeconds,
                                                              int reorderThresholdPendingRequests,
                                                              boolean isWeighted,
                                                              int maxWeightMultiple,
                                                              int minNumRacksPerWriteQuorum,
                                                              boolean enforceMinNumRacksPerWriteQuorum,
                                                              boolean ignoreLocalNodeInPlacementPolicy,
                                                              StatsLogger statsLogger,
                                                              BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L165">        checkNotNull(statsLogger, &quot;statsLogger should not be null, use NullStatsLogger instead.&quot;);</span>
<span class="nc" id="L166">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L167">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L168">        this.bookiesJoinedCounter = statsLogger.getOpStatsLogger(BOOKIES_JOINED);</span>
<span class="nc" id="L169">        this.bookiesLeftCounter = statsLogger.getOpStatsLogger(BOOKIES_LEFT);</span>
<span class="nc" id="L170">        this.readReorderedCounter = statsLogger.getOpStatsLogger(READ_REQUESTS_REORDERED);</span>
<span class="nc" id="L171">        this.failedToResolveNetworkLocationCounter = statsLogger.getCounter(FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNTER);</span>
<span class="nc" id="L172">        this.numWritableBookiesInDefaultRack = new Gauge&lt;Integer&gt;() {</span>
            @Override
            public Integer getDefaultValue() {
<span class="nc" id="L175">                return 0;</span>
            }

            @Override
            public Integer getSample() {
<span class="nc" id="L180">                rwLock.readLock().lock();</span>
                try {
<span class="nc" id="L182">                    return topology.countNumOfAvailableNodes(getDefaultRack(), Collections.emptySet());</span>
                } finally {
<span class="nc" id="L184">                    rwLock.readLock().unlock();</span>
                }
            }
        };
<span class="nc" id="L188">        this.statsLogger.registerGauge(NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK, numWritableBookiesInDefaultRack);</span>
<span class="nc" id="L189">        this.reorderReadsRandom = reorderReadsRandom;</span>
<span class="nc" id="L190">        this.stabilizePeriodSeconds = stabilizePeriodSeconds;</span>
<span class="nc" id="L191">        this.reorderThresholdPendingRequests = reorderThresholdPendingRequests;</span>
<span class="nc" id="L192">        this.dnsResolver = new DNSResolverDecorator(dnsResolver, () -&gt; this.getDefaultRack(),</span>
                failedToResolveNetworkLocationCounter);
<span class="nc" id="L194">        this.timer = timer;</span>
<span class="nc" id="L195">        this.minNumRacksPerWriteQuorum = minNumRacksPerWriteQuorum;</span>
<span class="nc" id="L196">        this.enforceMinNumRacksPerWriteQuorum = enforceMinNumRacksPerWriteQuorum;</span>
<span class="nc" id="L197">        this.ignoreLocalNodeInPlacementPolicy = ignoreLocalNodeInPlacementPolicy;</span>

        // create the network topology
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (stabilizePeriodSeconds &gt; 0) {</span>
<span class="nc" id="L201">            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);</span>
        } else {
<span class="nc" id="L203">            this.topology = new NetworkTopologyImpl();</span>
        }

<span class="nc" id="L206">        BookieNode bn = null;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (!ignoreLocalNodeInPlacementPolicy) {</span>
            try {
<span class="nc" id="L209">                bn = createDummyLocalBookieNode(InetAddress.getLocalHost().getHostAddress());</span>
<span class="nc" id="L210">            } catch (IOException e) {</span>
<span class="nc" id="L211">                LOG.error(&quot;Failed to get local host address : &quot;, e);</span>
<span class="nc" id="L212">            }</span>
        } else {
<span class="nc" id="L214">            LOG.info(&quot;Ignoring LocalNode in Placementpolicy&quot;);</span>
        }
<span class="nc" id="L216">        localNode = bn;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        LOG.info(&quot;Initialize rackaware ensemble placement policy @ {} @ {} : {}.&quot;,</span>
<span class="nc" id="L218">                localNode, null == localNode ? &quot;Unknown&quot; : localNode.getNetworkLocation(),</span>
<span class="nc" id="L219">                dnsResolver.getClass().getName());</span>

<span class="nc" id="L221">        this.isWeighted = isWeighted;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (this.isWeighted) {</span>
<span class="nc" id="L223">            this.maxWeightMultiple = maxWeightMultiple;</span>
<span class="nc" id="L224">            this.weightedSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L225">            LOG.info(&quot;Weight based placement with max multiple of &quot; + this.maxWeightMultiple);</span>
        } else {
<span class="nc" id="L227">            LOG.info(&quot;Not weighted&quot;);</span>
        }
<span class="nc" id="L229">        return this;</span>
    }

    /*
     * sets default rack for the policy.
     * i.e. region-aware policy may want to have /region/rack while regular
     * rack-aware policy needs /rack only since we cannot mix both styles
     */
    public RackawareEnsemblePlacementPolicyImpl withDefaultRack(String rack) {
<span class="nc" id="L238">        checkNotNull(rack, &quot;Default rack cannot be null&quot;);</span>

<span class="nc" id="L240">        this.defaultRack = rack;</span>
<span class="nc" id="L241">        return this;</span>
    }

    public String getDefaultRack() {
<span class="nc" id="L245">        return defaultRack;</span>
    }

    @Override
    public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,
                                                           Optional&lt;DNSToSwitchMapping&gt; optionalDnsResolver,
                                                           HashedWheelTimer timer,
                                                           FeatureProvider featureProvider,
                                                           StatsLogger statsLogger,
                                                           BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L255">        this.bookieAddressResolver = bookieAddressResolver;</span>
        DNSToSwitchMapping dnsResolver;
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (optionalDnsResolver.isPresent()) {</span>
<span class="nc" id="L258">            dnsResolver = optionalDnsResolver.get();</span>
        } else {
<span class="nc" id="L260">            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());</span>
            try {
<span class="nc" id="L262">                dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                if (dnsResolver instanceof Configurable) {</span>
<span class="nc" id="L264">                    ((Configurable) dnsResolver).setConf(conf);</span>
                }

<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (dnsResolver instanceof RackChangeNotifier) {</span>
<span class="nc" id="L268">                    ((RackChangeNotifier) dnsResolver).registerRackChangeListener(this);</span>
                }
<span class="nc" id="L270">            } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (!conf.getEnforceMinNumRacksPerWriteQuorum()) {</span>
<span class="nc" id="L272">                    LOG.error(&quot;Failed to initialize DNS Resolver {}, used default subnet resolver : {}&quot;,</span>
<span class="nc" id="L273">                            dnsResolverName, re, re.getMessage());</span>
<span class="nc" id="L274">                    dnsResolver = new DefaultResolver(() -&gt; this.getDefaultRack());</span>
                } else {
                    /*
                     * if minNumRacksPerWriteQuorum is enforced, then it
                     * shouldn't continue in the case of failure to create
                     * dnsResolver.
                     */
<span class="nc" id="L281">                    throw re;</span>
                }
<span class="nc" id="L283">            }</span>
        }
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (dnsResolver != null) {</span>
<span class="nc" id="L286">            dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
        }
<span class="nc" id="L288">        slowBookies = CacheBuilder.newBuilder()</span>
<span class="nc" id="L289">            .expireAfterWrite(conf.getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L290">            .build(new CacheLoader&lt;BookieId, Long&gt;() {</span>
                @Override
                public Long load(BookieId key) throws Exception {
<span class="nc" id="L293">                    return -1L;</span>
                }
            });
<span class="nc" id="L296">        return initialize(</span>
                dnsResolver,
                timer,
<span class="nc" id="L299">                conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),</span>
<span class="nc" id="L300">                conf.getNetworkTopologyStabilizePeriodSeconds(),</span>
<span class="nc" id="L301">                conf.getReorderThresholdPendingRequests(),</span>
<span class="nc" id="L302">                conf.getDiskWeightBasedPlacementEnabled(),</span>
<span class="nc" id="L303">                conf.getBookieMaxWeightMultipleForWeightBasedPlacement(),</span>
<span class="nc" id="L304">                conf.getMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L305">                conf.getEnforceMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L306">                conf.getIgnoreLocalNodeInPlacementPolicy(),</span>
                statsLogger,
                bookieAddressResolver);
    }

    @Override
    public void uninitalize() {
        // do nothing
<span class="nc" id="L314">    }</span>

    /*
     * this method should be called in readlock scope of 'rwLock'
     */
    protected Set&lt;BookieId&gt; addDefaultRackBookiesIfMinNumRacksIsEnforced(
            Set&lt;BookieId&gt; excludeBookies) {
        Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet;
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (enforceMinNumRacksPerWriteQuorum) {</span>
<span class="nc" id="L323">            Set&lt;BookieId&gt; bookiesInDefaultRack = null;</span>
<span class="nc" id="L324">            Set&lt;Node&gt; defaultRackLeaves = topology.getLeaves(getDefaultRack());</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (Node node : defaultRackLeaves) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (node instanceof BookieNode) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                    if (bookiesInDefaultRack == null) {</span>
<span class="nc" id="L328">                        bookiesInDefaultRack = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
                    }
<span class="nc" id="L330">                    bookiesInDefaultRack.add(((BookieNode) node).getAddr());</span>
                } else {
<span class="nc" id="L332">                    LOG.error(&quot;found non-BookieNode: {} as leaf of defaultrack: {}&quot;, node, getDefaultRack());</span>
                }
<span class="nc" id="L334">            }</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">            if ((bookiesInDefaultRack == null) || bookiesInDefaultRack.isEmpty()) {</span>
<span class="nc" id="L336">                comprehensiveExclusionBookiesSet = excludeBookies;</span>
            } else {
<span class="nc" id="L338">                comprehensiveExclusionBookiesSet = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
<span class="nc" id="L339">                comprehensiveExclusionBookiesSet.addAll(bookiesInDefaultRack);</span>
<span class="nc" id="L340">                LOG.info(&quot;enforceMinNumRacksPerWriteQuorum is enabled, so Excluding bookies of defaultRack: {}&quot;,</span>
                        bookiesInDefaultRack);
            }
<span class="nc" id="L343">        } else {</span>
<span class="nc" id="L344">            comprehensiveExclusionBookiesSet = excludeBookies;</span>
        }
<span class="nc" id="L346">        return comprehensiveExclusionBookiesSet;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L353">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L355">            Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = addDefaultRackBookiesIfMinNumRacksIsEnforced(</span>
                    excludeBookies);
<span class="nc" id="L357">            PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleResult = newEnsembleInternal(ensembleSize,</span>
                    writeQuorumSize, ackQuorumSize, comprehensiveExclusionBookiesSet, null, null);
<span class="nc" id="L359">            return newEnsembleResult;</span>
        } finally {
<span class="nc" id="L361">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize,
                                                                  int writeQuorumSize,
                                                                  int ackQuorumSize,
                                                                  Set&lt;BookieId&gt; excludeBookies,
                                                                  Ensemble&lt;BookieNode&gt; parentEnsemble,
                                                                  Predicate&lt;BookieNode&gt; parentPredicate)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L373">        return newEnsembleInternal(</span>
                ensembleSize,
                writeQuorumSize,
                ackQuorumSize,
                excludeBookies,
                parentEnsemble,
                parentPredicate);
    }

    protected PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleInternal(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            Ensemble&lt;BookieNode&gt; parentEnsemble,
            Predicate&lt;BookieNode&gt; parentPredicate) throws BKNotEnoughBookiesException {
<span class="nc" id="L389">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L391">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>
<span class="nc" id="L392">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L393">            RRTopologyAwareCoverageEnsemble ensemble =</span>
                    new RRTopologyAwareCoverageEnsemble(
                            ensembleSize,
                            writeQuorumSize,
                            ackQuorumSize,
                            RACKNAME_DISTANCE_FROM_LEAVES,
                            parentEnsemble,
                            parentPredicate,
                            minNumRacksPerWriteQuorumForThisEnsemble);
<span class="nc" id="L402">            BookieNode prevNode = null;</span>
<span class="nc" id="L403">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack, use the random algorithm.
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (numRacks &lt; 2) {</span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">                if (enforceMinNumRacksPerWriteQuorum &amp;&amp; (minNumRacksPerWriteQuorumForThisEnsemble &gt; 1)) {</span>
<span class="nc" id="L407">                    LOG.error(&quot;Only one rack available and minNumRacksPerWriteQuorum is enforced, so giving up&quot;);</span>
<span class="nc" id="L408">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="nc" id="L410">                List&lt;BookieNode&gt; bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.INSTANCE,</span>
                        ensemble);
<span class="nc" id="L412">                ArrayList&lt;BookieId&gt; addrs = new ArrayList&lt;BookieId&gt;(ensembleSize);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                for (BookieNode bn : bns) {</span>
<span class="nc" id="L414">                    addrs.add(bn.getAddr());</span>
<span class="nc" id="L415">                }</span>
<span class="nc" id="L416">                return PlacementResult.of(addrs, PlacementPolicyAdherence.FAIL);</span>
            }

<span class="nc bnc" id="L419" title="All 2 branches missed.">            for (int i = 0; i &lt; ensembleSize; i++) {</span>
                String curRack;
<span class="nc bnc" id="L421" title="All 2 branches missed.">                if (null == prevNode) {</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">                    if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L423">                        curRack = NodeBase.ROOT;</span>
                    } else {
<span class="nc" id="L425">                        curRack = localNode.getNetworkLocation();</span>
                    }
                } else {
<span class="nc" id="L428">                    curRack = &quot;~&quot; + prevNode.getNetworkLocation();</span>
                }
<span class="nc bnc" id="L430" title="All 2 branches missed.">                boolean firstBookieInTheEnsemble = (null == prevNode);</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">                prevNode = selectFromNetworkLocation(curRack, excludeNodes, ensemble, ensemble,</span>
                        !enforceMinNumRacksPerWriteQuorum || firstBookieInTheEnsemble);
            }
<span class="nc" id="L434">            List&lt;BookieId&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L436">                LOG.error(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L437">                          ensembleSize, bookieList);</span>
<span class="nc" id="L438">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L440">            return PlacementResult.of(bookieList,</span>
<span class="nc" id="L441">                                      isEnsembleAdheringToPlacementPolicy(</span>
                                              bookieList, writeQuorumSize, ackQuorumSize));
        } finally {
<span class="nc" id="L444">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;BookieId&gt; replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
            Map&lt;String, byte[]&gt; customMetadata, List&lt;BookieId&gt; currentEnsemble,
            BookieId bookieToReplace, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L453">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L455">            excludeBookies = addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies);</span>
<span class="nc" id="L456">            excludeBookies.addAll(currentEnsemble);</span>
<span class="nc" id="L457">            BookieNode bn = knownBookies.get(bookieToReplace);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (null == bn) {</span>
<span class="nc" id="L459">                bn = createBookieNode(bookieToReplace);</span>
            }

<span class="nc" id="L462">            Set&lt;Node&gt; ensembleNodes = convertBookiesToNodes(currentEnsemble);</span>
<span class="nc" id="L463">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>

<span class="nc" id="L465">            excludeNodes.addAll(ensembleNodes);</span>
<span class="nc" id="L466">            excludeNodes.add(bn);</span>
<span class="nc" id="L467">            ensembleNodes.remove(bn);</span>

<span class="nc" id="L469">            Set&lt;String&gt; networkLocationsToBeExcluded = getNetworkLocations(ensembleNodes);</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L472">                LOG.debug(&quot;Try to choose a new bookie to replace {} from ensemble {}, excluding {}.&quot;,</span>
                    bookieToReplace, ensembleNodes, excludeNodes);
            }
            // pick a candidate from same rack to replace
<span class="nc" id="L476">            BookieNode candidate = selectFromNetworkLocation(</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                    bn.getNetworkLocation(),</span>
                    networkLocationsToBeExcluded,
                    excludeNodes,
                    TruePredicate.INSTANCE,
                    EnsembleForReplacementWithNoConstraints.INSTANCE,
                    !enforceMinNumRacksPerWriteQuorum);
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L484">                LOG.debug(&quot;Bookie {} is chosen to replace bookie {}.&quot;, candidate, bn);</span>
            }
<span class="nc" id="L486">            BookieId candidateAddr = candidate.getAddr();</span>
<span class="nc" id="L487">            List&lt;BookieId&gt; newEnsemble = new ArrayList&lt;BookieId&gt;(currentEnsemble);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            if (currentEnsemble.isEmpty()) {</span>
                /*
                 * in testing code there are test cases which would pass empty
                 * currentEnsemble
                 */
<span class="nc" id="L493">                newEnsemble.add(candidateAddr);</span>
            } else {
<span class="nc" id="L495">                newEnsemble.set(currentEnsemble.indexOf(bookieToReplace), candidateAddr);</span>
            }
<span class="nc" id="L497">            return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L498">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L500">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(
            String networkLoc,
            Set&lt;Node&gt; excludeBookies,
            Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // select one from local rack
        try {
<span class="nc" id="L514">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L515">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L517">                LOG.error(</span>
                        &quot;Failed to choose a bookie from {} : &quot;
                                + &quot;excluded {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        networkLoc, excludeBookies);
<span class="nc" id="L521">                throw e;</span>
            }
<span class="nc" id="L523">            LOG.warn(&quot;Failed to choose a bookie from {} : &quot;</span>
                     + &quot;excluded {}, fallback to choose bookie randomly from the cluster.&quot;,
                     networkLoc, excludeBookies);
            // randomly choose one from whole cluster, ignore the provided predicate.
<span class="nc" id="L527">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc,
                                                   Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // first attempt to select one from local rack
        try {
<span class="nc" id="L541">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L542">        } catch (BKNotEnoughBookiesException e) {</span>
            /*
             * there is no enough bookie from local rack, select bookies from
             * the whole cluster and exclude the racks specified at
             * &lt;tt&gt;excludeRacks&lt;/tt&gt;.
             */
<span class="nc" id="L548">            return selectFromNetworkLocation(excludeRacks, excludeBookies, predicate, ensemble, fallbackToRandom);</span>
        }
    }


    /**
     * It randomly selects a {@link BookieNode} that is not on the &lt;i&gt;excludeRacks&lt;/i&gt; set, excluding the nodes in
     * &lt;i&gt;excludeBookies&lt;/i&gt; set. If it fails to find one, it selects a random {@link BookieNode} from the whole
     * cluster.
     */
    @Override
    public BookieNode selectFromNetworkLocation(Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {

<span class="nc" id="L566">        List&lt;BookieNode&gt; knownNodes = new ArrayList&lt;&gt;(knownBookies.values());</span>
<span class="nc" id="L567">        Set&lt;Node&gt; fullExclusionBookiesList = new HashSet&lt;Node&gt;(excludeBookies);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        for (BookieNode knownNode : knownNodes) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (excludeRacks.contains(knownNode.getNetworkLocation())) {</span>
<span class="nc" id="L570">                fullExclusionBookiesList.add(knownNode);</span>
            }
<span class="nc" id="L572">        }</span>

        try {
<span class="nc" id="L575">            return selectRandomInternal(knownNodes, 1, fullExclusionBookiesList, predicate, ensemble).get(0);</span>
<span class="nc" id="L576">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L578">                LOG.error(</span>
                        &quot;Failed to choose a bookie excluding Racks: {} &quot;
                                + &quot;Nodes: {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        excludeRacks, excludeBookies);
<span class="nc" id="L582">                throw e;</span>
            }

<span class="nc" id="L585">            LOG.warn(&quot;Failed to choose a bookie: excluded {}, fallback to choose bookie randomly from the cluster.&quot;,</span>
                    excludeBookies);
            // randomly choose one from whole cluster
<span class="nc" id="L588">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    private WeightedRandomSelection&lt;BookieNode&gt; prepareForWeightedSelection(List&lt;Node&gt; leaves) {
        // create a map of bookieNode-&gt;freeDiskSpace for this rack. The assumption is that
        // the number of nodes in a rack is of the order of 40, so it shouldn't be too bad
        // to build it every time during a ledger creation
<span class="nc" id="L596">        Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (Node n : leaves) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (!(n instanceof BookieNode)) {</span>
<span class="nc" id="L599">                continue;</span>
            }
<span class="nc" id="L601">            BookieNode bookie = (BookieNode) n;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (this.bookieInfoMap.containsKey(bookie)) {</span>
<span class="nc" id="L603">                rackMap.put(bookie, this.bookieInfoMap.get(bookie));</span>
            } else {
<span class="nc" id="L605">                rackMap.put(bookie, new BookieInfo());</span>
            }
<span class="nc" id="L607">        }</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (rackMap.size() == 0) {</span>
<span class="nc" id="L609">            return null;</span>
        }

<span class="nc" id="L612">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(</span>
                maxWeightMultiple);
<span class="nc" id="L614">        wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L615">        return wRSelection;</span>
    }

    /**
     * Choose random node under a given network path.
     *
     * @param netPath
     *          network path
     * @param excludeBookies
     *          exclude bookies
     * @param predicate
     *          predicate to check whether the target is a good target.
     * @param ensemble
     *          ensemble structure
     * @return chosen bookie.
     */
    protected BookieNode selectRandomFromRack(String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L633">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc" id="L634">        List&lt;Node&gt; leaves = new ArrayList&lt;Node&gt;(topology.getLeaves(netPath));</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (!this.isWeighted) {</span>
<span class="nc" id="L636">            Collections.shuffle(leaves);</span>
        } else {
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L639">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L641">            wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L643">                throw new BKNotEnoughBookiesException();</span>
            }
        }

<span class="nc" id="L647">        Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L648">        Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;Node&gt;();</span>
        while (true) {
            Node n;
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                    // Don't loop infinitely.
<span class="nc" id="L654">                    break;</span>
                }
<span class="nc" id="L656">                n = wRSelection.getNextRandom();</span>
<span class="nc" id="L657">                bookiesSeenSoFar.add(n);</span>
            } else {
<span class="nc bnc" id="L659" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L660">                    n = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L666">                continue;</span>
            }
<span class="nc bnc" id="L668" title="All 4 branches missed.">            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L669">                continue;</span>
            }
<span class="nc" id="L671">            BookieNode bn = (BookieNode) n;</span>
            // got a good candidate
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (ensemble.addNode(bn)) {</span>
                // add the candidate to exclude set
<span class="nc" id="L675">                excludeBookies.add(bn);</span>
            }
<span class="nc" id="L677">            return bn;</span>
        }
<span class="nc" id="L679">        throw new BKNotEnoughBookiesException();</span>
    }

    /**
     * Choose a random node from whole cluster.
     *
     * @param numBookies
     *          number bookies to choose
     * @param excludeBookies
     *          bookies set to exclude.
     * @param ensemble
     *          ensemble to hold the bookie chosen.
     * @return the bookie node chosen.
     * @throws BKNotEnoughBookiesException
     */
    protected List&lt;BookieNode&gt; selectRandom(int numBookies,
                                            Set&lt;Node&gt; excludeBookies,
                                            Predicate&lt;BookieNode&gt; predicate,
                                            Ensemble&lt;BookieNode&gt; ensemble)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L699">        return selectRandomInternal(null,  numBookies, excludeBookies, predicate, ensemble);</span>
    }

    protected List&lt;BookieNode&gt; selectRandomInternal(List&lt;BookieNode&gt; bookiesToSelectFrom,
                                                    int numBookies,
                                                    Set&lt;Node&gt; excludeBookies,
                                                    Predicate&lt;BookieNode&gt; predicate,
                                                    Ensemble&lt;BookieNode&gt; ensemble)
        throws BKNotEnoughBookiesException {
<span class="nc" id="L708">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (bookiesToSelectFrom == null) {</span>
            // If the list is null, we need to select from the entire knownBookies set
<span class="nc" id="L711">            wRSelection = this.weightedSelection;</span>
<span class="nc" id="L712">            bookiesToSelectFrom = new ArrayList&lt;BookieNode&gt;(knownBookies.values());</span>
        }
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (isWeighted) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (CollectionUtils.subtract(bookiesToSelectFrom, excludeBookies).size() &lt; numBookies) {</span>
<span class="nc" id="L716">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L719">                Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                for (BookieNode n : bookiesToSelectFrom) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                    if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L722">                        continue;</span>
                    }
<span class="nc bnc" id="L724" title="All 2 branches missed.">                    if (this.bookieInfoMap.containsKey(n)) {</span>
<span class="nc" id="L725">                        rackMap.put(n, this.bookieInfoMap.get(n));</span>
                    } else {
<span class="nc" id="L727">                        rackMap.put(n, new BookieInfo());</span>
                    }
<span class="nc" id="L729">                }</span>
<span class="nc" id="L730">                wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L731">                wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L732">            }</span>
        } else {
<span class="nc" id="L734">            Collections.shuffle(bookiesToSelectFrom);</span>
        }

        BookieNode bookie;
<span class="nc" id="L738">        List&lt;BookieNode&gt; newBookies = new ArrayList&lt;BookieNode&gt;(numBookies);</span>
<span class="nc" id="L739">        Iterator&lt;BookieNode&gt; it = bookiesToSelectFrom.iterator();</span>
<span class="nc" id="L740">        Set&lt;BookieNode&gt; bookiesSeenSoFar = new HashSet&lt;BookieNode&gt;();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        while (numBookies &gt; 0) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == bookiesToSelectFrom.size()) {</span>
                    // If we have gone through the whole available list of bookies,
                    // and yet haven't been able to satisfy the ensemble request, bail out.
                    // We don't want to loop infinitely.
<span class="nc" id="L747">                    break;</span>
                }
<span class="nc" id="L749">                bookie = wRSelection.getNextRandom();</span>
<span class="nc" id="L750">                bookiesSeenSoFar.add(bookie);</span>
            } else {
<span class="nc bnc" id="L752" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L753">                    bookie = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (excludeBookies.contains(bookie)) {</span>
<span class="nc" id="L759">                continue;</span>
            }

            // When durability is being enforced; we must not violate the
            // predicate even when selecting a random bookie; as durability
            // guarantee is not best effort; correctness is implied by it
<span class="nc bnc" id="L765" title="All 4 branches missed.">            if (enforceDurability &amp;&amp; !predicate.apply(bookie, ensemble)) {</span>
<span class="nc" id="L766">                continue;</span>
            }

<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (ensemble.addNode(bookie)) {</span>
<span class="nc" id="L770">                excludeBookies.add(bookie);</span>
<span class="nc" id="L771">                newBookies.add(bookie);</span>
<span class="nc" id="L772">                --numBookies;</span>
            }
        }
<span class="nc bnc" id="L775" title="All 2 branches missed.">        if (numBookies == 0) {</span>
<span class="nc" id="L776">            return newBookies;</span>
        }
<span class="nc" id="L778">        LOG.warn(&quot;Failed to find {} bookies : excludeBookies {}, allBookies {}.&quot;,</span>
<span class="nc" id="L779">            numBookies, excludeBookies, bookiesToSelectFrom);</span>

<span class="nc" id="L781">        throw new BKNotEnoughBookiesException();</span>
    }

    @Override
    public void registerSlowBookie(BookieId bookieSocketAddress, long entryId) {
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &lt;= 0) {</span>
            // only put bookies on slowBookies list if reorderThresholdPendingRequests is *not* set (0);
            // otherwise, rely on reordering of reads based on reorderThresholdPendingRequests
<span class="nc" id="L789">            slowBookies.put(bookieSocketAddress, entryId);</span>
        }
<span class="nc" id="L791">    }</span>

    @Override
    public DistributionSchedule.WriteSet reorderReadSequence(
            List&lt;BookieId&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo,
            DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L798">        Map&lt;Integer, String&gt; writeSetWithRegion = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L800">            writeSetWithRegion.put(writeSet.get(i), &quot;&quot;);</span>
        }
<span class="nc" id="L802">        return reorderReadSequenceWithRegion(</span>
<span class="nc" id="L803">            ensemble, writeSet, writeSetWithRegion, bookiesHealthInfo, false, &quot;&quot;, writeSet.size());</span>
    }

    /**
     * This function orders the read sequence with a given region. For region-unaware policies (e.g.
     * RackAware), we pass in false for regionAware and an empty myRegion. When this happens, any
     * remote list will stay empty. The ordering is as follows (the R* at the beginning of each list item
     * is only present for region aware policies).
     *      1. available (local) bookies
     *      2. R* a remote bookie (based on remoteNodeInReorderSequence
     *      3. R* remaining (local) bookies
     *      4. R* remaining remote bookies
     *      5. read only bookies
     *      6. slow bookies
     *      7. unavailable bookies
     *
     * @param ensemble
     *          ensemble of bookies
     * @param writeSet
     *          write set
     * @param writeSetWithRegion
     *          write set with region information
     * @param bookiesHealthInfo
     *          heuristics about health of boookies
     * @param regionAware
     *          whether or not a region-aware policy is used
     * @param myRegion
     *          current region of policy
     * @param remoteNodeInReorderSequence
     *          number of local bookies to try before trying a remote bookie
     * @return ordering of bookies to send read to
     */
    DistributionSchedule.WriteSet reorderReadSequenceWithRegion(
        List&lt;BookieId&gt; ensemble,
        DistributionSchedule.WriteSet writeSet,
        Map&lt;Integer, String&gt; writeSetWithRegion,
        BookiesHealthInfo bookiesHealthInfo,
        boolean regionAware,
        String myRegion,
        int remoteNodeInReorderSequence) {
<span class="nc bnc" id="L843" title="All 4 branches missed.">        boolean useRegionAware = regionAware &amp;&amp; (!myRegion.equals(UNKNOWN_REGION));</span>
<span class="nc" id="L844">        int ensembleSize = ensemble.size();</span>

        // For rack aware, If all the bookies in the write set are available, simply return the original write set,
        // to avoid creating more lists
<span class="nc" id="L848">        boolean isAnyBookieUnavailable = false;</span>

<span class="nc bnc" id="L850" title="All 4 branches missed.">        if (useRegionAware || reorderReadsRandom) {</span>
<span class="nc" id="L851">            isAnyBookieUnavailable = true;</span>
        } else {
<span class="nc bnc" id="L853" title="All 2 branches missed.">            for (int i = 0; i &lt; ensemble.size(); i++) {</span>
<span class="nc" id="L854">                BookieId bookieAddr = ensemble.get(i);</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">                if ((!knownBookies.containsKey(bookieAddr) &amp;&amp; !readOnlyBookies.contains(bookieAddr))</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                    || slowBookies.getIfPresent(bookieAddr) != null) {</span>
                    // Found at least one bookie not available in the ensemble, or in slowBookies
<span class="nc" id="L858">                    isAnyBookieUnavailable = true;</span>
<span class="nc" id="L859">                    break;</span>
                }
            }
        }

<span class="nc" id="L864">        boolean reordered = false;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &gt; 0) {</span>
            // if there are no slow or unavailable bookies, capture each bookie's number of
            // pending request to reorder requests based on a threshold of pending requests

            // number of pending requests per bookie (same index as writeSet)
<span class="nc" id="L870">            long[] pendingReqs = new long[writeSet.size()];</span>
<span class="nc" id="L871">            int bestBookieIdx = -1;</span>

<span class="nc bnc" id="L873" title="All 2 branches missed.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L874">                pendingReqs[i] = bookiesHealthInfo.getBookiePendingRequests(ensemble.get(writeSet.get(i)));</span>
<span class="nc bnc" id="L875" title="All 4 branches missed.">                if (bestBookieIdx &lt; 0 || pendingReqs[i] &lt; pendingReqs[bestBookieIdx]) {</span>
<span class="nc" id="L876">                    bestBookieIdx = i;</span>
                }
            }

            // reorder the writeSet if the currently first bookie in our writeSet has at
            // least
            // reorderThresholdPendingRequests more outstanding request than the best bookie
<span class="nc bnc" id="L883" title="All 4 branches missed.">            if (bestBookieIdx &gt; 0 &amp;&amp; pendingReqs[0] &gt;= pendingReqs[bestBookieIdx] + reorderThresholdPendingRequests) {</span>
                // We're not reordering the entire write set, but only move the best bookie
                // to the first place. Chances are good that this bookie will be fast enough
                // to not trigger the speculativeReadTimeout. But even if it hits that timeout,
                // things may have changed by then so much that whichever bookie we put second
                // may actually not be the second-best choice any more.
<span class="nc bnc" id="L889" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L890">                    LOG.debug(&quot;read set reordered from {} ({} pending) to {} ({} pending)&quot;,</span>
<span class="nc" id="L891">                            ensemble.get(writeSet.get(0)), pendingReqs[0], ensemble.get(writeSet.get(bestBookieIdx)),</span>
<span class="nc" id="L892">                            pendingReqs[bestBookieIdx]);</span>
                }
<span class="nc" id="L894">                writeSet.moveAndShift(bestBookieIdx, 0);</span>
<span class="nc" id="L895">                reordered = true;</span>
            }
        }

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (!isAnyBookieUnavailable) {</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (reordered) {</span>
<span class="nc" id="L901">                readReorderedCounter.registerSuccessfulValue(1);</span>
            }
<span class="nc" id="L903">            return writeSet;</span>
        }

<span class="nc bnc" id="L906" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L907">            int idx = writeSet.get(i);</span>
<span class="nc" id="L908">            BookieId address = ensemble.get(idx);</span>
<span class="nc" id="L909">            String region = writeSetWithRegion.get(idx);</span>
<span class="nc" id="L910">            Long lastFailedEntryOnBookie = bookiesHealthInfo.getBookieFailureHistory(address);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (null == knownBookies.get(address)) {</span>
                // there isn't too much differences between readonly bookies
                // from unavailable bookies. since there
                // is no write requests to them, so we shouldn't try reading
                // from readonly bookie prior to writable bookies.
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if ((null == readOnlyBookies)</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                    || !readOnlyBookies.contains(address)) {</span>
<span class="nc" id="L918">                    writeSet.set(i, idx | UNAVAIL_MASK);</span>
                } else {
<span class="nc bnc" id="L920" title="All 2 branches missed.">                    if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L921">                        long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
                        // use slow bookies with less pending requests first
<span class="nc" id="L923">                        long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L924">                        writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L925">                    } else {</span>
<span class="nc" id="L926">                        writeSet.set(i, idx | READ_ONLY_MASK);</span>
                    }
                }
<span class="nc bnc" id="L929" title="All 2 branches missed.">            } else if (lastFailedEntryOnBookie &lt; 0) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L931">                    long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
<span class="nc" id="L932">                    long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L933">                    writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L934">                } else {</span>
<span class="nc bnc" id="L935" title="All 4 branches missed.">                    if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L936">                        writeSet.set(i, idx | REMOTE_MASK);</span>
                    } else {
<span class="nc" id="L938">                        writeSet.set(i, idx | LOCAL_MASK);</span>
                    }
                }
            } else {
                // use bookies with earlier failed entryIds first
<span class="nc" id="L943">                long failIdx = lastFailedEntryOnBookie * ensembleSize + idx;</span>
<span class="nc bnc" id="L944" title="All 4 branches missed.">                if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L945">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | REMOTE_FAIL_MASK);</span>
                } else {
<span class="nc" id="L947">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | LOCAL_FAIL_MASK);</span>
                }
            }
        }

        // Add a mask to ensure the sort is stable, sort,
        // and then remove mask. This maintains stability as
        // long as there are fewer than 16 bookies in the write set.
<span class="nc bnc" id="L955" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L956">            writeSet.set(i, writeSet.get(i) | ((i &amp; 0xF) &lt;&lt; 20));</span>
        }
<span class="nc" id="L958">        writeSet.sort();</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L960">            writeSet.set(i, writeSet.get(i) &amp; ~((0xF) &lt;&lt; 20));</span>
        }

<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (reorderReadsRandom) {</span>
<span class="nc" id="L964">            shuffleWithMask(writeSet, LOCAL_MASK, MASK_BITS);</span>
<span class="nc" id="L965">            shuffleWithMask(writeSet, REMOTE_MASK, MASK_BITS);</span>
<span class="nc" id="L966">            shuffleWithMask(writeSet, READ_ONLY_MASK, MASK_BITS);</span>
<span class="nc" id="L967">            shuffleWithMask(writeSet, UNAVAIL_MASK, MASK_BITS);</span>
        }

        // nodes within a region are ordered as follows
        // (Random?) list of nodes that have no history of failure
        // Nodes with Failure history are ordered in the reverse
        // order of the most recent entry that generated an error
        // The sort will have put them in correct order,
        // so remove the bits that sort by age.
<span class="nc bnc" id="L976" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L977">            int mask = writeSet.get(i) &amp; MASK_BITS;</span>
<span class="nc" id="L978">            int idx = (writeSet.get(i) &amp; ~MASK_BITS) % ensembleSize;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (mask == LOCAL_FAIL_MASK) {</span>
<span class="nc" id="L980">                writeSet.set(i, LOCAL_MASK | idx);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            } else if (mask == REMOTE_FAIL_MASK) {</span>
<span class="nc" id="L982">                writeSet.set(i, REMOTE_MASK | idx);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            } else if (mask == SLOW_MASK) {</span>
<span class="nc" id="L984">                writeSet.set(i, SLOW_MASK | idx);</span>
            }
        }

        // Insert a node from the remote region at the specified location so
        // we try more than one region within the max allowed latency
<span class="nc" id="L990">        int firstRemote = -1;</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if ((writeSet.get(i) &amp; MASK_BITS) == REMOTE_MASK) {</span>
<span class="nc" id="L993">                firstRemote = i;</span>
<span class="nc" id="L994">                break;</span>
            }
        }
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (firstRemote != -1) {</span>
<span class="nc" id="L998">            int i = 0;</span>
            for (; i &lt; remoteNodeInReorderSequence
<span class="nc bnc" id="L1000" title="All 4 branches missed.">                &amp;&amp; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                if ((writeSet.get(i) &amp; MASK_BITS) != LOCAL_MASK) {</span>
<span class="nc" id="L1002">                    break;</span>
                }
            }
<span class="nc" id="L1005">            writeSet.moveAndShift(firstRemote, i);</span>
        }


        // remove all masks
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1011">            writeSet.set(i, writeSet.get(i) &amp; ~MASK_BITS);</span>
        }
<span class="nc" id="L1013">        readReorderedCounter.registerSuccessfulValue(1);</span>
<span class="nc" id="L1014">        return writeSet;</span>
    }

    // this method should be called in readlock scope of 'rwlock'
    @Override
    public PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy(List&lt;BookieId&gt; ensembleList,
            int writeQuorumSize, int ackQuorumSize) {
<span class="nc" id="L1021">        int ensembleSize = ensembleList.size();</span>
<span class="nc" id="L1022">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1023">        HashSet&lt;String&gt; racksInQuorum = new HashSet&lt;String&gt;();</span>
        BookieId bookie;
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        for (int i = 0; i &lt; ensembleList.size(); i++) {</span>
<span class="nc" id="L1026">            racksInQuorum.clear();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L1028">                bookie = ensembleList.get((i + j) % ensembleSize);</span>
                try {
<span class="nc" id="L1030">                    racksInQuorum.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc" id="L1031">                } catch (Exception e) {</span>
                    /*
                     * any issue/exception in analyzing whether ensemble is
                     * strictly adhering to placement policy should be
                     * swallowed.
                     */
<span class="nc" id="L1037">                    LOG.warn(&quot;Received exception while trying to get network location of bookie: {}&quot;, bookie, e);</span>
<span class="nc" id="L1038">                }</span>
            }
<span class="nc bnc" id="L1040" title="All 4 branches missed.">            if ((racksInQuorum.size() &lt; minNumRacksPerWriteQuorumForThisEnsemble)</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                    || (enforceMinNumRacksPerWriteQuorum &amp;&amp; racksInQuorum.contains(getDefaultRack()))) {</span>
<span class="nc" id="L1042">                return PlacementPolicyAdherence.FAIL;</span>
            }
        }
<span class="nc" id="L1045">        return PlacementPolicyAdherence.MEETS_STRICT;</span>
    }

    @Override
    public boolean areAckedBookiesAdheringToPlacementPolicy(Set&lt;BookieId&gt; ackedBookies,
                                                            int writeQuorumSize,
                                                            int ackQuorumSize) {
<span class="nc" id="L1052">        HashSet&lt;String&gt; rackCounter = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1053">        int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>

<span class="nc" id="L1055">        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();</span>
<span class="nc" id="L1056">        readLock.lock();</span>
        try {
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            for (BookieId bookie : ackedBookies) {</span>
<span class="nc" id="L1059">                rackCounter.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc" id="L1060">            }</span>

            // Check to make sure that ensemble is writing to `minNumberOfRacks`'s number of racks at least.
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1064">                LOG.debug(&quot;areAckedBookiesAdheringToPlacementPolicy returning {} because number of racks = {} and &quot;</span>
                          + &quot;minNumRacksPerWriteQuorum = {}&quot;,
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                          rackCounter.size() &gt;= minNumRacksPerWriteQuorum,</span>
<span class="nc" id="L1067">                          rackCounter.size(),</span>
<span class="nc" id="L1068">                          minNumRacksPerWriteQuorum);</span>
            }
        } finally {
<span class="nc" id="L1071">            readLock.unlock();</span>
        }
<span class="nc bnc" id="L1073" title="All 2 branches missed.">        return rackCounter.size() &gt;= minWriteQuorumNumRacksPerWriteQuorum;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>
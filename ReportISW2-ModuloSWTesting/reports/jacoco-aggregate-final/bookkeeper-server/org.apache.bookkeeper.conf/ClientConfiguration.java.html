<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Tests</a> &gt; <a href="../index.html" class="el_bundle">bookkeeper-server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.conf</a> &gt; <span class="el_source">ClientConfiguration.java</span></div><h1>ClientConfiguration.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.conf;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.bookkeeper.util.BookKeeperConstants.FEATURE_DISABLE_ENSEMBLE_CHANGE;

import io.netty.buffer.ByteBuf;

import java.util.concurrent.TimeUnit;

import org.apache.bookkeeper.client.BookKeeper.DigestType;
import org.apache.bookkeeper.client.EnsemblePlacementPolicy;
import org.apache.bookkeeper.client.LedgerHandle;
import org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy;
import org.apache.bookkeeper.client.api.BookKeeperBuilder;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.discover.RegistrationClient;
import org.apache.bookkeeper.discover.ZKRegistrationClient;
import org.apache.bookkeeper.replication.Auditor;
import org.apache.commons.configuration.ConfigurationException;


/**
 * Configuration settings for client side.
 */
public class ClientConfiguration extends AbstractConfiguration&lt;ClientConfiguration&gt; {

    // Throttle value
    protected static final String THROTTLE = &quot;throttle&quot;;

    // Digest Type
    protected static final String DIGEST_TYPE = &quot;digestType&quot;;
    protected static final String ENABLE_DIGEST_TYPE_AUTODETECTION = &quot;enableDigestTypeAutodetection&quot;;

    // Passwd
    protected static final String PASSWD = &quot;passwd&quot;;

    // Client TLS (@deprecated since 4.7.0)
    /**
     * @deprecated Use {@link #TLS_KEYSTORE_TYPE}
     */
    @Deprecated
    protected static final String CLIENT_TLS_KEYSTORE_TYPE = &quot;clientKeyStoreType&quot;;

    /**
     * @deprecated Use {@link #TLS_KEYSTORE}
     */
    @Deprecated
    protected static final String CLIENT_TLS_KEYSTORE = &quot;clientKeyStore&quot;;

    /**
     * @deprecated Use {@link #TLS_KEYSTORE_PASSWORD_PATH}
     */
    @Deprecated
    protected static final String CLIENT_TLS_KEYSTORE_PASSWORD_PATH = &quot;clientKeyStorePasswordPath&quot;;

    /**
     * @deprecated Use {@link #TLS_TRUSTSTORE_TYPE}
     */
    @Deprecated
    protected static final String CLIENT_TLS_TRUSTSTORE_TYPE = &quot;clientTrustStoreType&quot;;

    /**
     * @deprecated Use {@link #TLS_TRUSTSTORE}
     */
    @Deprecated
    protected static final String CLIENT_TLS_TRUSTSTORE = &quot;clientTrustStore&quot;;

    /**
     * @deprecated Use {@link #TLS_TRUSTSTORE_PASSWORD_PATH}
     */
    @Deprecated
    protected static final String CLIENT_TLS_TRUSTSTORE_PASSWORD_PATH = &quot;clientTrustStorePasswordPath&quot;;

    // NIO Parameters
    protected static final String CLIENT_TCP_NODELAY = &quot;clientTcpNoDelay&quot;;
    protected static final String CLIENT_SOCK_KEEPALIVE = &quot;clientSockKeepalive&quot;;
    protected static final String CLIENT_SENDBUFFER_SIZE = &quot;clientSendBufferSize&quot;;
    protected static final String CLIENT_RECEIVEBUFFER_SIZE = &quot;clientReceiveBufferSize&quot;;
    protected static final String CLIENT_WRITEBUFFER_LOW_WATER_MARK = &quot;clientWriteBufferLowWaterMark&quot;;
    protected static final String CLIENT_WRITEBUFFER_HIGH_WATER_MARK = &quot;clientWriteBufferHighWaterMark&quot;;
    protected static final String CLIENT_CONNECT_TIMEOUT_MILLIS = &quot;clientConnectTimeoutMillis&quot;;
    protected static final String NUM_CHANNELS_PER_BOOKIE = &quot;numChannelsPerBookie&quot;;
    protected static final String USE_V2_WIRE_PROTOCOL = &quot;useV2WireProtocol&quot;;
    protected static final String NETTY_USE_POOLED_BUFFERS = &quot;nettyUsePooledBuffers&quot;;

    // Read Parameters
    protected static final String READ_TIMEOUT = &quot;readTimeout&quot;;
    protected static final String SPECULATIVE_READ_TIMEOUT = &quot;speculativeReadTimeout&quot;;
    protected static final String FIRST_SPECULATIVE_READ_TIMEOUT = &quot;firstSpeculativeReadTimeout&quot;;
    protected static final String MAX_SPECULATIVE_READ_TIMEOUT = &quot;maxSpeculativeReadTimeout&quot;;
    protected static final String SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER =
        &quot;speculativeReadTimeoutBackoffMultiplier&quot;;
    protected static final String FIRST_SPECULATIVE_READ_LAC_TIMEOUT = &quot;firstSpeculativeReadLACTimeout&quot;;
    protected static final String MAX_SPECULATIVE_READ_LAC_TIMEOUT = &quot;maxSpeculativeReadLACTimeout&quot;;
    protected static final String SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER =
        &quot;speculativeReadLACTimeoutBackoffMultiplier&quot;;
    protected static final String ENABLE_PARALLEL_RECOVERY_READ = &quot;enableParallelRecoveryRead&quot;;
    protected static final String RECOVERY_READ_BATCH_SIZE = &quot;recoveryReadBatchSize&quot;;
    protected static final String REORDER_READ_SEQUENCE_ENABLED = &quot;reorderReadSequenceEnabled&quot;;
    protected static final String STICKY_READS_ENABLED = &quot;stickyReadSEnabled&quot;;
    // Add Parameters
    protected static final String OPPORTUNISTIC_STRIPING = &quot;opportunisticStriping&quot;;
    protected static final String DELAY_ENSEMBLE_CHANGE = &quot;delayEnsembleChange&quot;;
    protected static final String MAX_ALLOWED_ENSEMBLE_CHANGES = &quot;maxNumEnsembleChanges&quot;;
    // Timeout Setting
    protected static final String ADD_ENTRY_TIMEOUT_SEC = &quot;addEntryTimeoutSec&quot;;
    protected static final String ADD_ENTRY_QUORUM_TIMEOUT_SEC = &quot;addEntryQuorumTimeoutSec&quot;;
    protected static final String READ_ENTRY_TIMEOUT_SEC = &quot;readEntryTimeoutSec&quot;;
    protected static final String TIMEOUT_MONITOR_INTERVAL_SEC = &quot;timeoutMonitorIntervalSec&quot;;
    protected static final String TIMEOUT_TASK_INTERVAL_MILLIS = &quot;timeoutTaskIntervalMillis&quot;;
    protected static final String EXPLICIT_LAC_INTERVAL = &quot;explicitLacInterval&quot;;
    protected static final String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = &quot;pcbcTimeoutTimerTickDurationMs&quot;;
    protected static final String PCBC_TIMEOUT_TIMER_NUM_TICKS = &quot;pcbcTimeoutTimerNumTicks&quot;;
    protected static final String TIMEOUT_TIMER_TICK_DURATION_MS = &quot;timeoutTimerTickDurationMs&quot;;
    protected static final String TIMEOUT_TIMER_NUM_TICKS = &quot;timeoutTimerNumTicks&quot;;
    // backpressure configuration
    protected static final String WAIT_TIMEOUT_ON_BACKPRESSURE = &quot;waitTimeoutOnBackpressureMs&quot;;

    // Bookie health check settings
    protected static final String BOOKIE_HEALTH_CHECK_ENABLED = &quot;bookieHealthCheckEnabled&quot;;
    protected static final String BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS = &quot;bookieHealthCheckIntervalSeconds&quot;;
    protected static final String BOOKIE_ERROR_THRESHOLD_PER_INTERVAL = &quot;bookieErrorThresholdPerInterval&quot;;
    protected static final String BOOKIE_QUARANTINE_TIME_SECONDS = &quot;bookieQuarantineTimeSeconds&quot;;
    protected static final String BOOKIE_QUARANTINE_RATIO = &quot;bookieQuarantineRatio&quot;;

    // Bookie info poll interval
    protected static final String DISK_WEIGHT_BASED_PLACEMENT_ENABLED = &quot;diskWeightBasedPlacementEnabled&quot;;
    protected static final String GET_BOOKIE_INFO_INTERVAL_SECONDS = &quot;getBookieInfoIntervalSeconds&quot;;
    protected static final String GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS = &quot;getBookieInfoRetryIntervalSeconds&quot;;
    protected static final String BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT =
        &quot;bookieMaxMultipleForWeightBasedPlacement&quot;;
    protected static final String GET_BOOKIE_INFO_TIMEOUT_SECS = &quot;getBookieInfoTimeoutSecs&quot;;
    protected static final String START_TLS_TIMEOUT_SECS = &quot;startTLSTimeoutSecs&quot;;
    protected static final String TLS_HOSTNAME_VERIFICATION_ENABLED = &quot;tlsHostnameVerificationEnabled&quot;;

    // Number of Threads
    protected static final String NUM_WORKER_THREADS = &quot;numWorkerThreads&quot;;
    protected static final String NUM_IO_THREADS = &quot;numIOThreads&quot;;

    // Ensemble Placement Policy
    public static final String ENSEMBLE_PLACEMENT_POLICY = &quot;ensemblePlacementPolicy&quot;;
    protected static final String NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS = &quot;networkTopologyStabilizePeriodSeconds&quot;;
    protected static final String READ_REORDER_THRESHOLD_PENDING_REQUESTS = &quot;readReorderThresholdPendingRequests&quot;;
    protected static final String ENSEMBLE_PLACEMENT_POLICY_ORDER_SLOW_BOOKIES =
        &quot;ensemblePlacementPolicyOrderSlowBookies&quot;;

    // Stats
    protected static final String ENABLE_TASK_EXECUTION_STATS = &quot;enableTaskExecutionStats&quot;;
    protected static final String TASK_EXECUTION_WARN_TIME_MICROS = &quot;taskExecutionWarnTimeMicros&quot;;

    // Failure History Settings
    protected static final String ENABLE_BOOKIE_FAILURE_TRACKING = &quot;enableBookieFailureTracking&quot;;
    protected static final String BOOKIE_FAILURE_HISTORY_EXPIRATION_MS = &quot;bookieFailureHistoryExpirationMSec&quot;;

    // Discovery
    protected static final String FOLLOW_BOOKIE_ADDRESS_TRACKING = &quot;enableBookieAddressTracking&quot;;

    // Names of dynamic features
    protected static final String DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME = &quot;disableEnsembleChangeFeatureName&quot;;

    // Role of the client
    protected static final String CLIENT_ROLE = &quot;clientRole&quot;;

    /**
     * This client will act as a standard client.
     */
    public static final String CLIENT_ROLE_STANDARD = &quot;standard&quot;;

    /**
     * This client will act as a system client, like the {@link Auditor}.
     */
    public static final String CLIENT_ROLE_SYSTEM = &quot;system&quot;;

    // Client auth provider factory class name. It must be configured on Bookies to for the Auditor
    protected static final String CLIENT_AUTH_PROVIDER_FACTORY_CLASS = &quot;clientAuthProviderFactoryClass&quot;;

    // Registration Client
    protected static final String REGISTRATION_CLIENT_CLASS = &quot;registrationClientClass&quot;;

    // Logs
    protected static final String CLIENT_CONNECT_BOOKIE_UNAVAILABLE_LOG_THROTTLING =
            &quot;clientConnectBookieUnavailableLogThrottling&quot;;

    /**
     * Construct a default client-side configuration.
     */
    public ClientConfiguration() {
<span class="nc" id="L205">        super();</span>
<span class="nc" id="L206">    }</span>

    /**
     * Construct a client-side configuration using a base configuration.
     *
     * @param conf
     *          Base configuration
     */
    public ClientConfiguration(AbstractConfiguration conf) {
<span class="nc" id="L215">        super();</span>
<span class="nc" id="L216">        loadConf(conf);</span>
<span class="nc" id="L217">    }</span>

    /**
     * Get throttle value.
     *
     * @return throttle value
     * @see #setThrottleValue
     */
    public int getThrottleValue() {
<span class="nc" id="L226">        return this.getInt(THROTTLE, 5000);</span>
    }

    /**
     * Set throttle value.
     *
     * &lt;p&gt;Since BookKeeper process requests in asynchronous way, it will holds
     * those pending request in queue. You may easily run it out of memory
     * if producing too many requests than the capability of bookie servers can handle.
     * To prevent that from happening, you can set a throttle value here.
     *
     * &lt;p&gt;Setting the throttle value to 0, will disable any throttling.
     *
     * @param throttle
     *          Throttle Value
     * @return client configuration
     */
    public ClientConfiguration setThrottleValue(int throttle) {
<span class="nc" id="L244">        this.setProperty(THROTTLE, Integer.toString(throttle));</span>
<span class="nc" id="L245">        return this;</span>
    }

    /**
     * Get autodetection of digest type.
     *
     * &lt;p&gt;Ignores provided digestType, if enabled and uses one from ledger metadata instead.
     * Incompatible with ledger created by bookie versions &amp;lt; 4.2
     *
     * &lt;p&gt;It is turned on by default since 4.7.
     *
     * @return flag to enable/disable autodetection of digest type.
     */
    public boolean getEnableDigestTypeAutodetection() {
<span class="nc" id="L259">        return getBoolean(ENABLE_DIGEST_TYPE_AUTODETECTION, true);</span>
    }

    /**
     * Enable autodetection of digest type.
     * Ignores provided digestType, if enabled and uses one from ledger metadata instead.
     * Incompatible with ledger created by bookie versions &amp;lt; 4.2
     *
     * @return client configuration.
     */
    public ClientConfiguration setEnableDigestTypeAutodetection(boolean enable) {
<span class="nc" id="L270">        this.setProperty(ENABLE_DIGEST_TYPE_AUTODETECTION, enable);</span>
<span class="nc" id="L271">        return this;</span>
    }

    /**
     * Get digest type used in bookkeeper admin.
     *
     * @return digest type
     * @see #setBookieRecoveryDigestType
     */
    public DigestType getBookieRecoveryDigestType() {
<span class="nc" id="L281">        return DigestType.valueOf(this.getString(DIGEST_TYPE, DigestType.CRC32.toString()));</span>
    }

    /**
     * Set digest type used in bookkeeper admin.
     *
     * &lt;p&gt;Digest Type and Passwd used to open ledgers for admin tool
     * For now, assume that all ledgers were created with the same DigestType
     * and password. In the future, this admin tool will need to know for each
     * ledger, what was the DigestType and password used to create it before it
     * can open it. These values will come from System properties, though fixed
     * defaults are defined here.
     *
     * @param digestType
     *          Digest Type
     * @return client configuration
     */
    public ClientConfiguration setBookieRecoveryDigestType(DigestType digestType) {
<span class="nc" id="L299">        this.setProperty(DIGEST_TYPE, digestType.toString());</span>
<span class="nc" id="L300">        return this;</span>
    }

    /**
     * Get passwd used in bookkeeper admin.
     *
     * @return password
     * @see #setBookieRecoveryPasswd
     */
    public byte[] getBookieRecoveryPasswd() {
<span class="nc" id="L310">        return this.getString(PASSWD, &quot;&quot;).getBytes(UTF_8);</span>
    }

    /**
     * Set passwd used in bookkeeper admin.
     *
     * &lt;p&gt;Digest Type and Passwd used to open ledgers for admin tool
     * For now, assume that all ledgers were created with the same DigestType
     * and password. In the future, this admin tool will need to know for each
     * ledger, what was the DigestType and password used to create it before it
     * can open it. These values will come from System properties, though fixed
     * defaults are defined here.
     *
     * @param passwd
     *          Password
     * @return client configuration
     */
    public ClientConfiguration setBookieRecoveryPasswd(byte[] passwd) {
<span class="nc" id="L328">        setProperty(PASSWD, new String(passwd, UTF_8));</span>
<span class="nc" id="L329">        return this;</span>
    }

    /**
     * Is tcp connection no delay.
     *
     * @return tcp socket nodelay setting
     * @see #setClientTcpNoDelay
     */
    public boolean getClientTcpNoDelay() {
<span class="nc" id="L339">        return getBoolean(CLIENT_TCP_NODELAY, true);</span>
    }

    /**
     * Set socket nodelay setting.
     *
     * &lt;p&gt;This settings is used to enabled/disabled Nagle's algorithm, which is a means of
     * improving the efficiency of TCP/IP networks by reducing the number of packets
     * that need to be sent over the network. If you are sending many small messages,
     * such that more than one can fit in a single IP packet, setting client.tcpnodelay
     * to false to enable Nagle algorithm can provide better performance.
     * &lt;br&gt;
     * Default value is true.
     *
     * @param noDelay
     *          NoDelay setting
     * @return client configuration
     */
    public ClientConfiguration setClientTcpNoDelay(boolean noDelay) {
<span class="nc" id="L358">        setProperty(CLIENT_TCP_NODELAY, Boolean.toString(noDelay));</span>
<span class="nc" id="L359">        return this;</span>
    }

    /**
     * get socket keepalive.
     *
     * @return socket keepalive setting
     */
    public boolean getClientSockKeepalive() {
<span class="nc" id="L368">        return getBoolean(CLIENT_SOCK_KEEPALIVE, true);</span>
    }

    /**
     * Set socket keepalive setting.
     *
     * &lt;p&gt;This setting is used to send keep-alive messages on connection-oriented sockets.
     *
     * @param keepalive
     *            KeepAlive setting
     * @return client configuration
     */
    public ClientConfiguration setClientSockKeepalive(boolean keepalive) {
<span class="nc" id="L381">        setProperty(CLIENT_SOCK_KEEPALIVE, Boolean.toString(keepalive));</span>
<span class="nc" id="L382">        return this;</span>
    }

    /**
     * Get client netty channel send buffer size.
     *
     * @return client netty channel send buffer size
     */
    public int getClientSendBufferSize() {
<span class="nc" id="L391">        return getInt(CLIENT_SENDBUFFER_SIZE, 1 * 1024 * 1024);</span>
    }

    /**
     * Set client netty channel send buffer size.
     *
     * @param bufferSize
     *          client netty channel send buffer size.
     * @return client configuration.
     */
    public ClientConfiguration setClientSendBufferSize(int bufferSize) {
<span class="nc" id="L402">        setProperty(CLIENT_SENDBUFFER_SIZE, bufferSize);</span>
<span class="nc" id="L403">        return this;</span>
    }

    /**
     * Get client netty channel receive buffer size.
     *
     * @return client netty channel receive buffer size.
     */
    public int getClientReceiveBufferSize() {
<span class="nc" id="L412">        return getInt(CLIENT_RECEIVEBUFFER_SIZE, 1 * 1024 * 1024);</span>
    }

    /**
     * Set client netty channel receive buffer size.
     *
     * @param bufferSize
     *          netty channel receive buffer size.
     * @return client configuration.
     */
    public ClientConfiguration setClientReceiveBufferSize(int bufferSize) {
<span class="nc" id="L423">        setProperty(CLIENT_RECEIVEBUFFER_SIZE, bufferSize);</span>
<span class="nc" id="L424">        return this;</span>
    }

    /**
     * Get client netty channel write buffer low water mark.
     *
     * @return netty channel write buffer low water mark.
     */
    public int getClientWriteBufferLowWaterMark() {
<span class="nc" id="L433">        return getInt(CLIENT_WRITEBUFFER_LOW_WATER_MARK, 384 * 1024);</span>
    }

    /**
     * Set client netty channel write buffer low water mark.
     *
     * @param waterMark
     *          netty channel write buffer low water mark.
     * @return client configuration.
     */
    public ClientConfiguration setClientWriteBufferLowWaterMark(int waterMark) {
<span class="nc" id="L444">        setProperty(CLIENT_WRITEBUFFER_LOW_WATER_MARK, waterMark);</span>
<span class="nc" id="L445">        return this;</span>
    }

    /**
     * Get client netty channel write buffer high water mark.
     *
     * @return netty channel write buffer high water mark.
     */
    public int getClientWriteBufferHighWaterMark() {
<span class="nc" id="L454">        return getInt(CLIENT_WRITEBUFFER_HIGH_WATER_MARK, 512 * 1024);</span>
    }

    /**
     * Set client netty channel write buffer high water mark.
     *
     * @param waterMark
     *          netty channel write buffer high water mark.
     * @return client configuration.
     */
    public ClientConfiguration setClientWriteBufferHighWaterMark(int waterMark) {
<span class="nc" id="L465">        setProperty(CLIENT_WRITEBUFFER_HIGH_WATER_MARK, waterMark);</span>
<span class="nc" id="L466">        return this;</span>
    }

    /**
     * Get the tick duration in milliseconds that used for timeout timer.
     *
     * @return tick duration in milliseconds
     */
    public long getTimeoutTimerTickDurationMs() {
<span class="nc" id="L475">        return getLong(TIMEOUT_TIMER_TICK_DURATION_MS, 100);</span>
    }

    /**
     * Set the tick duration in milliseconds that used for timeout timer.
     *
     * @param tickDuration
     *          tick duration in milliseconds.
     * @return client configuration.
     */
    public ClientConfiguration setTimeoutTimerTickDurationMs(long tickDuration) {
<span class="nc" id="L486">        setProperty(TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);</span>
<span class="nc" id="L487">        return this;</span>
    }

    /**
     * Get number of ticks that used for timeout timer.
     *
     * @return number of ticks that used for timeout timer.
     */
    public int getTimeoutTimerNumTicks() {
<span class="nc" id="L496">        return getInt(TIMEOUT_TIMER_NUM_TICKS, 1024);</span>
    }

    /**
     * Set number of ticks that used for timeout timer.
     *
     * @param numTicks
     *          number of ticks that used for timeout timer.
     * @return client configuration.
     */
    public ClientConfiguration setTimeoutTimerNumTicks(int numTicks) {
<span class="nc" id="L507">        setProperty(TIMEOUT_TIMER_NUM_TICKS, numTicks);</span>
<span class="nc" id="L508">        return this;</span>
    }

    /**
     * Get client netty connect timeout in millis.
     *
     * @return client netty connect timeout in millis.
     */
    public int getClientConnectTimeoutMillis() {
        // 10 seconds as netty default value.
<span class="nc" id="L518">        return getInt(CLIENT_CONNECT_TIMEOUT_MILLIS, 10000);</span>
    }

    /**
     * Set client netty connect timeout in millis.
     *
     * @param connectTimeoutMillis
     *          client netty connect timeout in millis.
     * @return client configuration.
     */
    public ClientConfiguration setClientConnectTimeoutMillis(int connectTimeoutMillis) {
<span class="nc" id="L529">        setProperty(CLIENT_CONNECT_TIMEOUT_MILLIS, connectTimeoutMillis);</span>
<span class="nc" id="L530">        return this;</span>
    }

    /**
     * Get num channels per bookie.
     *
     * @return num channels per bookie.
     */
    public int getNumChannelsPerBookie() {
<span class="nc" id="L539">        return getInt(NUM_CHANNELS_PER_BOOKIE, 1);</span>
    }

    /**
     * Set num channels per bookie.
     *
     * @param numChannelsPerBookie
     *          num channels per bookie.
     * @return client configuration.
     */
    public ClientConfiguration setNumChannelsPerBookie(int numChannelsPerBookie) {
<span class="nc" id="L550">        setProperty(NUM_CHANNELS_PER_BOOKIE, numChannelsPerBookie);</span>
<span class="nc" id="L551">        return this;</span>
    }

    /**
     * Use older Bookkeeper wire protocol (no protobuf).
     *
     * @return whether or not to use older Bookkeeper wire protocol (no protobuf)
     */
    public boolean getUseV2WireProtocol() {
<span class="nc" id="L560">        return getBoolean(USE_V2_WIRE_PROTOCOL, false);</span>
    }

    /**
     * Set whether or not to use older Bookkeeper wire protocol (no protobuf).
     *
     * @param useV2WireProtocol
     *          whether or not to use older Bookkeeper wire protocol (no protobuf)
     * @return client configuration.
     */
    public ClientConfiguration setUseV2WireProtocol(boolean useV2WireProtocol) {
<span class="nc" id="L571">        setProperty(USE_V2_WIRE_PROTOCOL, useV2WireProtocol);</span>
<span class="nc" id="L572">        return this;</span>
    }

    /**
     * Get the socket read timeout. This is the number of
     * seconds we wait without hearing a response from a bookie
     * before we consider it failed.
     *
     * &lt;p&gt;The default is 5 seconds.
     *
     * @return the current read timeout in seconds
     * @deprecated use {@link #getReadEntryTimeout()} or {@link #getAddEntryTimeout()} instead
     */
    @Deprecated
    public int getReadTimeout() {
<span class="nc" id="L587">        return getInt(READ_TIMEOUT, 5);</span>
    }

    /**
     * Set the socket read timeout.
     * @see #getReadTimeout()
     * @param timeout The new read timeout in seconds
     * @return client configuration
     * @deprecated use {@link #setReadEntryTimeout(int)} or {@link #setAddEntryTimeout(int)} instead
     */
    @Deprecated
    public ClientConfiguration setReadTimeout(int timeout) {
<span class="nc" id="L599">        setProperty(READ_TIMEOUT, Integer.toString(timeout));</span>
<span class="nc" id="L600">        return this;</span>
    }

    /**
     * Get the timeout for add request. This is the number of seconds we wait without hearing
     * a response for add request from a bookie before we consider it failed.
     *
     * &lt;p&gt;The default value is 5 second for backwards compatibility.
     *
     * @return add entry timeout.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public int getAddEntryTimeout() {
<span class="nc" id="L613">        return getInt(ADD_ENTRY_TIMEOUT_SEC, getReadTimeout());</span>
    }

    /**
     * Set timeout for add entry request.
     * @see #getAddEntryTimeout()
     *
     * @param timeout
     *          The new add entry timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setAddEntryTimeout(int timeout) {
<span class="nc" id="L625">        setProperty(ADD_ENTRY_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L626">        return this;</span>
    }

    /**
     * Get the timeout for top-level add request. That is, the amount of time we should spend
     * waiting for ack quorum.
     *
     * @return add entry ack quorum timeout.
     */
    public int getAddEntryQuorumTimeout() {
<span class="nc" id="L636">        return getInt(ADD_ENTRY_QUORUM_TIMEOUT_SEC, -1);</span>
    }

    /**
     * Set timeout for top-level add entry request.
     * @see #getAddEntryQuorumTimeout()
     *
     * @param timeout
     *          The new add entry ack quorum timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setAddEntryQuorumTimeout(int timeout) {
<span class="nc" id="L648">        setProperty(ADD_ENTRY_QUORUM_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L649">        return this;</span>
    }

    /**
     * Get the timeout for read entry. This is the number of seconds we wait without hearing
     * a response for read entry request from a bookie before we consider it failed. By default,
     * we use socket timeout specified at {@link #getReadTimeout()}.
     *
     * @return read entry timeout.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public int getReadEntryTimeout() {
<span class="nc" id="L661">        return getInt(READ_ENTRY_TIMEOUT_SEC, getReadTimeout());</span>
    }

    /**
     * Set the timeout for read entry request.
     * @see #getReadEntryTimeout()
     *
     * @param timeout
     *          The new read entry timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setReadEntryTimeout(int timeout) {
<span class="nc" id="L673">        setProperty(READ_ENTRY_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L674">        return this;</span>
    }

    /**
     * Get the interval between successive executions of the operation timeout monitor. This value is in seconds.
     *
     * @see #setTimeoutMonitorIntervalSec(long)
     * @return the interval at which request timeouts will be checked
     */
    public long getTimeoutMonitorIntervalSec() {
<span class="nc" id="L684">        int minTimeout = Math.min(Math.min(getAddEntryQuorumTimeout(),</span>
<span class="nc" id="L685">                                           getAddEntryTimeout()), getReadEntryTimeout());</span>
<span class="nc" id="L686">        return getLong(TIMEOUT_MONITOR_INTERVAL_SEC, Math.max(minTimeout / 2, 1));</span>
    }

    /**
     * Set the interval between successive executions of the operation timeout monitor. The value in seconds.
     * Every X seconds, all outstanding add and read operations are checked to see if they have been running
     * for longer than their configured timeout. Any that have been will be errored out.
     *
     * &lt;p&gt;This timeout should be set to a value which is a fraction of the values of
     * {@link #getAddEntryQuorumTimeout}, {@link #getAddEntryTimeout} and {@link #getReadEntryTimeout},
     * so that these timeouts run in a timely fashion.
     *
     * @param timeoutInterval The timeout monitor interval, in seconds
     * @return client configuration
     */
    public ClientConfiguration setTimeoutMonitorIntervalSec(long timeoutInterval) {
<span class="nc" id="L702">        setProperty(TIMEOUT_MONITOR_INTERVAL_SEC, Long.toString(timeoutInterval));</span>
<span class="nc" id="L703">        return this;</span>
    }

    /**
     * Get the interval between successive executions of the PerChannelBookieClient's TimeoutTask. This value is in
     * milliseconds. Every X milliseconds, the timeout task will be executed and it will error out entries that have
     * timed out.
     *
     * &lt;p&gt;We do it more aggressive to not accumulate pending requests due to slow responses.
     *
     * @return the interval at which request timeouts will be checked
     */
    @Deprecated
    public long getTimeoutTaskIntervalMillis() {
<span class="nc" id="L717">        return getLong(TIMEOUT_TASK_INTERVAL_MILLIS,</span>
<span class="nc" id="L718">                TimeUnit.SECONDS.toMillis(Math.min(getAddEntryTimeout(), getReadEntryTimeout())) / 2);</span>
    }

    @Deprecated
    public ClientConfiguration setTimeoutTaskIntervalMillis(long timeoutMillis) {
<span class="nc" id="L723">        setProperty(TIMEOUT_TASK_INTERVAL_MILLIS, Long.toString(timeoutMillis));</span>
<span class="nc" id="L724">        return this;</span>
    }

    /**
     * Get the configured interval between  explicit LACs to bookies.
     * Generally LACs are piggy-backed on writes, and user can configure
     * the interval between these protocol messages. A value of '0' disables
     * sending any explicit LACs.
     *
     * @return interval between explicit LACs
     */
    public int getExplictLacInterval() {
<span class="nc" id="L736">        return getInt(EXPLICIT_LAC_INTERVAL, 0);</span>
    }

    /**
     * Set the interval to check the need for sending an explicit LAC.
     * @param interval
     *        Number of milli seconds between checking the need for sending an explict LAC.
     * @return Client configuration.
     */
    public ClientConfiguration setExplictLacInterval(int interval) {
<span class="nc" id="L746">        setProperty(EXPLICIT_LAC_INTERVAL, interval);</span>
<span class="nc" id="L747">        return this;</span>
    }

    /**
     * Get the tick duration in milliseconds that used for the
     * HashedWheelTimer that used by PCBC to timeout
     * requests.
     *
     * @return tick duration in milliseconds
     */
    @Deprecated
    public long getPCBCTimeoutTimerTickDurationMs() {
<span class="nc" id="L759">        return getLong(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, 100);</span>
    }

    /**
     * Set the tick duration in milliseconds that used for
     * HashedWheelTimer that used by PCBC to timeout
     * requests. Be aware of HashedWheelTimer if you
     * are going to modify this setting.
     *
     * @see #getPCBCTimeoutTimerTickDurationMs()
     *
     * @param tickDuration
     *          tick duration in milliseconds.
     * @return client configuration.
     */
    @Deprecated
    public ClientConfiguration setPCBCTimeoutTimerTickDurationMs(long tickDuration) {
<span class="nc" id="L776">        setProperty(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);</span>
<span class="nc" id="L777">        return this;</span>
    }

    /**
     * Get number of ticks that used for
     * HashedWheelTimer that used by PCBC to timeout
     * requests.
     *
     * @return number of ticks that used for timeout timer.
     */
    @Deprecated
    public int getPCBCTimeoutTimerNumTicks() {
<span class="nc" id="L789">        return getInt(PCBC_TIMEOUT_TIMER_NUM_TICKS, 1024);</span>
    }

    /**
     * Set number of ticks that used for
     * HashedWheelTimer that used by PCBC to timeout request.
     * Be aware of HashedWheelTimer if you are going to modify
     * this setting.
     *
     * @see #getPCBCTimeoutTimerNumTicks()
     *
     * @param numTicks
     *          number of ticks that used for timeout timer.
     * @return client configuration.
     */
    @Deprecated
    public ClientConfiguration setPCBCTimeoutTimerNumTicks(int numTicks) {
<span class="nc" id="L806">        setProperty(PCBC_TIMEOUT_TIMER_NUM_TICKS, numTicks);</span>
<span class="nc" id="L807">        return this;</span>
    }

    /**
     * Timeout controlling wait on request send in case of unresponsive bookie(s)
     * (i.e. bookie in long GC etc.)
     *
     * @return timeout value
     *        negative value disables the feature
     *        0 to allow request to fail immediately
     *        Default is -1 (disabled)
     */
    public long getWaitTimeoutOnBackpressureMillis() {
<span class="nc" id="L820">        return getLong(WAIT_TIMEOUT_ON_BACKPRESSURE, -1);</span>
    }

    /**
     * Timeout controlling wait on request send in case of unresponsive bookie(s)
     * (i.e. bookie in long GC etc.)
     *
     * @param value
     *        negative value disables the feature
     *        0 to allow request to fail immediately
     *        Default is -1 (disabled)
     * @return client configuration.
     */
    public ClientConfiguration setWaitTimeoutOnBackpressureMillis(long value) {
<span class="nc" id="L834">        setProperty(WAIT_TIMEOUT_ON_BACKPRESSURE, value);</span>
<span class="nc" id="L835">        return this;</span>
    }

    /**
     * Get the number of worker threads. This is the number of
     * worker threads used by bookkeeper client to submit operations.
     *
     * @return the number of worker threads
     */
    public int getNumWorkerThreads() {
<span class="nc" id="L845">        return getInt(NUM_WORKER_THREADS, Runtime.getRuntime().availableProcessors());</span>
    }

    /**
     * Set the number of worker threads.
     *
     * &lt;p&gt;
     * NOTE: setting the number of worker threads after BookKeeper object is constructed
     * will not take any effect on the number of threads in the pool.
     * &lt;/p&gt;
     *
     * @see #getNumWorkerThreads()
     * @param numThreads number of worker threads used for bookkeeper
     * @return client configuration
     */
    public ClientConfiguration setNumWorkerThreads(int numThreads) {
<span class="nc" id="L861">        setProperty(NUM_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L862">        return this;</span>
    }

    /**
     * Get the number of IO threads. This is the number of
     * threads used by Netty to handle TCP connections.
     *
     * @return the number of IO threads
     */
    public int getNumIOThreads() {
<span class="nc" id="L872">        return getInt(NUM_IO_THREADS, 2 * Runtime.getRuntime().availableProcessors());</span>
    }

    /**
     * Set the number of IO threads.
     *
     * &lt;p&gt;
     * This is the number of threads used by Netty to handle TCP connections.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: setting the number of IO threads after BookKeeper object is constructed
     * will not take any effect on the number of threads in the pool.
     * &lt;/p&gt;
     *
     * @see #getNumIOThreads()
     * @param numThreads number of IO threads used for bookkeeper
     * @return client configuration
     */
    public ClientConfiguration setNumIOThreads(int numThreads) {
<span class="nc" id="L892">        setProperty(NUM_IO_THREADS, numThreads);</span>
<span class="nc" id="L893">        return this;</span>
    }

    /**
     * Get the period of time after which a speculative entry read should be triggered.
     * A speculative entry read is sent to the next replica bookie before
     * an error or response has been received for the previous entry read request.
     *
     * &lt;p&gt;A speculative entry read is only sent if we have not heard from the current
     * replica bookie during the entire read operation which may comprise of many entries.
     *
     * &lt;p&gt;Speculative reads allow the client to avoid having to wait for the connect timeout
     * in the case that a bookie has failed. It induces higher load on the network and on
     * bookies. This should be taken into account before changing this configuration value.
     *
     * @see org.apache.bookkeeper.client.LedgerHandle#asyncReadEntries
     * @return the speculative read timeout in milliseconds. Default 2000.
     */
    public int getSpeculativeReadTimeout() {
<span class="nc" id="L912">        return getInt(SPECULATIVE_READ_TIMEOUT, 2000);</span>
    }

    /**
     * Set the speculative read timeout. A lower timeout will reduce read latency in the
     * case of a failed bookie, while increasing the load on bookies and the network.
     *
     * &lt;p&gt;The default is 2000 milliseconds. A value of 0 will disable speculative reads
     * completely.
     *
     * @see #getSpeculativeReadTimeout()
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L927">        setProperty(SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L928">        return this;</span>
    }

    /**
     * Get the first speculative read timeout.
     *
     * @return first speculative read timeout.
     */
    public int getFirstSpeculativeReadTimeout() {
<span class="nc" id="L937">        return getInt(FIRST_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());</span>
    }

    /**
     * Set the first speculative read timeout.
     *
     * @param timeout
     *          first speculative read timeout.
     * @return client configuration.
     */
    public ClientConfiguration setFirstSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L948">        setProperty(FIRST_SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L949">        return this;</span>
    }

    /**
     * Multipler to use when determining time between successive speculative read requests.
     *
     * @return speculative read timeout backoff multiplier.
     */
    public float getSpeculativeReadTimeoutBackoffMultiplier() {
<span class="nc" id="L958">        return getFloat(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);</span>
    }

    /**
     * Set the multipler to use when determining time between successive speculative read requests.
     *
     * @param speculativeReadTimeoutBackoffMultiplier
     *          multipler to use when determining time between successive speculative read requests.
     * @return client configuration.
     */
    public ClientConfiguration setSpeculativeReadTimeoutBackoffMultiplier(
            float speculativeReadTimeoutBackoffMultiplier) {
<span class="nc" id="L970">        setProperty(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadTimeoutBackoffMultiplier);</span>
<span class="nc" id="L971">        return this;</span>
    }

    /**
     * Multipler to use when determining time between successive speculative read LAC requests.
     *
     * @return speculative read LAC timeout backoff multiplier.
     */
    public float getSpeculativeReadLACTimeoutBackoffMultiplier() {
<span class="nc" id="L980">        return getFloat(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);</span>
    }

    /**
     * Set the multipler to use when determining time between successive speculative read LAC requests.
     *
     * @param speculativeReadLACTimeoutBackoffMultiplier
     *          multipler to use when determining time between successive speculative read LAC requests.
     * @return client configuration.
     */
    public ClientConfiguration setSpeculativeReadLACTimeoutBackoffMultiplier(
            float speculativeReadLACTimeoutBackoffMultiplier) {
<span class="nc" id="L992">        setProperty(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadLACTimeoutBackoffMultiplier);</span>
<span class="nc" id="L993">        return this;</span>
    }

    /**
     * Get the max speculative read timeout.
     *
     * @return max speculative read timeout.
     */
    public int getMaxSpeculativeReadTimeout() {
<span class="nc" id="L1002">        return getInt(MAX_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());</span>
    }

    /**
     * Set the max speculative read timeout.
     *
     * @param timeout
     *          max speculative read timeout.
     * @return client configuration.
     */
    public ClientConfiguration setMaxSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L1013">        setProperty(MAX_SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L1014">        return this;</span>
    }

    /**
     * Get the period of time after which the first speculative read last add confirmed and entry
     * should be triggered.
     * A speculative entry request is sent to the next replica bookie before
     * an error or response has been received for the previous entry read request.
     *
     * &lt;p&gt;A speculative entry read is only sent if we have not heard from the current
     * replica bookie during the entire read operation which may comprise of many entries.
     *
     * &lt;p&gt;Speculative requests allow the client to avoid having to wait for the connect timeout
     * in the case that a bookie has failed. It induces higher load on the network and on
     * bookies. This should be taken into account before changing this configuration value.
     *
     * @return the speculative request timeout in milliseconds. Default 1500.
     */
    public int getFirstSpeculativeReadLACTimeout() {
<span class="nc" id="L1033">        return getInt(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, 1500);</span>
    }


    /**
     * Get the maximum interval between successive speculative read last add confirmed and entry
     * requests.
     *
     * @return the max speculative request timeout in milliseconds. Default 5000.
     */
    public int getMaxSpeculativeReadLACTimeout() {
<span class="nc" id="L1044">        return getInt(MAX_SPECULATIVE_READ_LAC_TIMEOUT, 5000);</span>
    }

    /**
     * Set the period of time after which the first speculative read last add confirmed and entry
     * should be triggered.
     * A lower timeout will reduce read latency in the case of a failed bookie,
     * while increasing the load on bookies and the network.
     *
     * &lt;p&gt;The default is 1500 milliseconds. A value of 0 will disable speculative reads
     * completely.
     *
     * @see #getSpeculativeReadTimeout()
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setFirstSpeculativeReadLACTimeout(int timeout) {
<span class="nc" id="L1061">        setProperty(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, timeout);</span>
<span class="nc" id="L1062">        return this;</span>
    }

    /**
     * Set the maximum interval between successive speculative read last add confirmed and entry
     * requests.
     *
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setMaxSpeculativeReadLACTimeout(int timeout) {
<span class="nc" id="L1073">        setProperty(MAX_SPECULATIVE_READ_LAC_TIMEOUT, timeout);</span>
<span class="nc" id="L1074">        return this;</span>
    }

    /**
     * Whether to enable parallel reading in recovery read.
     *
     * @return true if enable parallel reading in recovery read. otherwise, return false.
     */
    public boolean getEnableParallelRecoveryRead() {
<span class="nc" id="L1083">        return getBoolean(ENABLE_PARALLEL_RECOVERY_READ, false);</span>
    }

    /**
     * Enable/Disable parallel reading in recovery read.
     *
     * @param enabled
     *          flag to enable/disable parallel reading in recovery read.
     * @return client configuration.
     */
    public ClientConfiguration setEnableParallelRecoveryRead(boolean enabled) {
<span class="nc" id="L1094">        setProperty(ENABLE_PARALLEL_RECOVERY_READ, enabled);</span>
<span class="nc" id="L1095">        return this;</span>
    }

    /**
     * Get Recovery Read Batch Size.
     *
     * @return recovery read batch size.
     */
    public int getRecoveryReadBatchSize() {
<span class="nc" id="L1104">        return getInt(RECOVERY_READ_BATCH_SIZE, 1);</span>
    }

    /**
     * Set Recovery Read Batch Size.
     *
     * @param batchSize
     *          recovery read batch size.
     * @return client configuration.
     */
    public ClientConfiguration setRecoveryReadBatchSize(int batchSize) {
<span class="nc" id="L1115">        setProperty(RECOVERY_READ_BATCH_SIZE, batchSize);</span>
<span class="nc" id="L1116">        return this;</span>
    }

    /**
     * If reorder read sequence enabled or not.
     *
     * @return true if reorder read sequence is enabled, otherwise false.
     */
    public boolean isReorderReadSequenceEnabled() {
<span class="nc" id="L1125">        return getBoolean(REORDER_READ_SEQUENCE_ENABLED, false);</span>
    }

    /**
     * Enable/disable reordering read sequence on reading entries.
     *
     * &lt;p&gt;If this flag is enabled, the client will use
     * {@link EnsemblePlacementPolicy#reorderReadSequence(java.util.ArrayList,
     * org.apache.bookkeeper.client.BookiesHealthInfo, org.apache.bookkeeper.client.DistributionSchedule.WriteSet)}
     * to figure out a better read sequence to attempt reads from replicas and use
     * {@link EnsemblePlacementPolicy#reorderReadLACSequence(java.util.ArrayList,
     * org.apache.bookkeeper.client.BookiesHealthInfo, org.apache.bookkeeper.client.DistributionSchedule.WriteSet)}
     * to figure out a better read sequence to attempt long poll reads from replicas.
     *
     * &lt;p&gt;The order of read sequence is determined by the placement policy implementations.
     *
     * @param enabled the flag to enable/disable reorder read sequence.
     * @return client configuration instance.
     */
    public ClientConfiguration setReorderReadSequenceEnabled(boolean enabled) {
<span class="nc" id="L1145">        setProperty(REORDER_READ_SEQUENCE_ENABLED, enabled);</span>
<span class="nc" id="L1146">        return this;</span>
    }

    /**
     * If read operation should be sticky to a single bookie or not.
     *
     * @return true if reorder read sequence is enabled, otherwise false.
     */
    public boolean isStickyReadsEnabled() {
<span class="nc" id="L1155">        return getBoolean(STICKY_READS_ENABLED, false);</span>
    }

    /**
     * Enable/disable having read operations for a ledger to be sticky to
     * a single bookie.
     *
     * &lt;p&gt;If this flag is enabled, the client will use one single bookie (by
     * preference) to read all entries for a ledger.
     *
     * &lt;p&gt;Having all the read to one bookie will increase the chances that
     * a read request will be fullfilled by Bookie read cache (or OS file
     * system cache) when doing sequential reads.
     *
     * @param enabled the flag to enable/disable sticky reads.
     * @return client configuration instance.
     */
    public ClientConfiguration setStickyReadsEnabled(boolean enabled) {
<span class="nc" id="L1173">        setProperty(STICKY_READS_ENABLED, enabled);</span>
<span class="nc" id="L1174">        return this;</span>
    }

    /**
     * Get Ensemble Placement Policy Class.
     *
     * @return ensemble placement policy class.
     */
    public Class&lt;? extends EnsemblePlacementPolicy&gt; getEnsemblePlacementPolicy()
            throws ConfigurationException {
<span class="nc" id="L1184">        return ReflectionUtils.getClass(this, ENSEMBLE_PLACEMENT_POLICY,</span>
                RackawareEnsemblePlacementPolicy.class,
                EnsemblePlacementPolicy.class,
                                        DEFAULT_LOADER);
    }

    /**
     * Set Ensemble Placement Policy Class.
     *
     * @param policyClass
     *          Ensemble Placement Policy Class.
     */
    public ClientConfiguration setEnsemblePlacementPolicy(Class&lt;? extends EnsemblePlacementPolicy&gt; policyClass) {
<span class="nc" id="L1197">        setProperty(ENSEMBLE_PLACEMENT_POLICY, policyClass.getName());</span>
<span class="nc" id="L1198">        return this;</span>
    }

    /**
     * Get the threshold for the number of pending requests beyond which to reorder
     * reads. If &amp;lt;= zero, this feature is turned off.
     *
     * @return the threshold for the number of pending requests beyond which to
     *         reorder reads.
     */
    public int getReorderThresholdPendingRequests() {
<span class="nc" id="L1209">        return getInt(READ_REORDER_THRESHOLD_PENDING_REQUESTS, 0);</span>
    }

    /**
     * Set the threshold for the number of pending requests beyond which to reorder
     * reads. If zero, this feature is turned off.
     *
     * @param threshold
     *            The threshold for the number of pending requests beyond which to
     *            reorder reads.
     */
    public ClientConfiguration setReorderThresholdPendingRequests(int threshold) {
<span class="nc" id="L1221">        setProperty(READ_REORDER_THRESHOLD_PENDING_REQUESTS, threshold);</span>
<span class="nc" id="L1222">        return this;</span>
    }

    /**
     * Get the network topology stabilize period in seconds. if it is zero, this feature is turned off.
     *
     * @return network topology stabilize period in seconds.
     */
    public int getNetworkTopologyStabilizePeriodSeconds() {
<span class="nc" id="L1231">        return getInt(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, 0);</span>
    }

    /**
     * Set the network topology stabilize period in seconds.
     *
     * @see #getNetworkTopologyStabilizePeriodSeconds()
     * @param seconds stabilize period in seconds
     * @return client configuration.
     */
    public ClientConfiguration setNetworkTopologyStabilizePeriodSeconds(int seconds) {
<span class="nc" id="L1242">        setProperty(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, seconds);</span>
<span class="nc" id="L1243">        return this;</span>
    }

    /**
     * Whether to order slow bookies in placement policy.
     *
     * @return flag of whether to order slow bookies in placement policy or not.
     */
    public boolean getEnsemblePlacementPolicySlowBookies() {
<span class="nc" id="L1252">        return getBoolean(ENSEMBLE_PLACEMENT_POLICY_ORDER_SLOW_BOOKIES, false);</span>
    }

    /**
     * Enable/Disable ordering slow bookies in placement policy.
     *
     * @param enabled
     *          flag to enable/disable ordering slow bookies in placement policy.
     * @return client configuration.
     */
    public ClientConfiguration setEnsemblePlacementPolicySlowBookies(boolean enabled) {
<span class="nc" id="L1263">        setProperty(ENSEMBLE_PLACEMENT_POLICY_ORDER_SLOW_BOOKIES, enabled);</span>
<span class="nc" id="L1264">        return this;</span>
    }

    /**
     * Whether to enable recording task execution stats.
     *
     * @return flag to enable/disable recording task execution stats.
     */
    public boolean getEnableTaskExecutionStats() {
<span class="nc" id="L1273">        return getBoolean(ENABLE_TASK_EXECUTION_STATS, false);</span>
    }

    /**
     * Enable/Disable recording task execution stats.
     *
     * @param enabled
     *          flag to enable/disable recording task execution stats.
     * @return client configuration.
     */
    public ClientConfiguration setEnableTaskExecutionStats(boolean enabled) {
<span class="nc" id="L1284">        setProperty(ENABLE_TASK_EXECUTION_STATS, enabled);</span>
<span class="nc" id="L1285">        return this;</span>
    }

    /**
     * Get task execution duration which triggers a warning.
     *
     * @return time in microseconds which triggers a warning.
     */
    public long getTaskExecutionWarnTimeMicros() {
<span class="nc" id="L1294">        return getLong(TASK_EXECUTION_WARN_TIME_MICROS, TimeUnit.SECONDS.toMicros(1));</span>
    }

    /**
     * Set task execution duration which triggers a warning.
     *
     * @param warnTime
     *          time in microseconds which triggers a warning.
     * @return client configuration.
     */
    public ClientConfiguration setTaskExecutionWarnTimeMicros(long warnTime) {
<span class="nc" id="L1305">        setProperty(TASK_EXECUTION_WARN_TIME_MICROS, warnTime);</span>
<span class="nc" id="L1306">        return this;</span>
    }

    /**
     * Check if bookie health check is enabled.
     *
     * @return
     */
    public boolean isBookieHealthCheckEnabled() {
<span class="nc" id="L1315">        return getBoolean(BOOKIE_HEALTH_CHECK_ENABLED, false);</span>
    }

    /**
     * Enables the bookie health check.
     *
     * &lt;p&gt;
     * If the number of read/write errors for a bookie exceeds {@link #getBookieErrorThresholdPerInterval()} per
     * interval, that bookie is quarantined for {@link #getBookieQuarantineTimeSeconds()} seconds. During this
     * quarantined period, the client will try not to use this bookie when creating new ensembles.
     * &lt;/p&gt;
     *
     * &lt;p&gt;By default, the bookie health check is &lt;b&gt;disabled&lt;/b&gt;.
     *
     * @return client configuration
     */
    public ClientConfiguration enableBookieHealthCheck() {
<span class="nc" id="L1332">        setProperty(BOOKIE_HEALTH_CHECK_ENABLED, true);</span>
<span class="nc" id="L1333">        return this;</span>
    }

    /**
     * Get the bookie health check interval in seconds.
     *
     * @return
     */
    public int getBookieHealthCheckIntervalSeconds() {
<span class="nc" id="L1342">        return getInt(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, 60);</span>
    }

    /**
     * Set the bookie health check interval. Default is 60 seconds.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param interval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setBookieHealthCheckInterval(int interval, TimeUnit unit) {
<span class="nc" id="L1357">        setProperty(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, unit.toSeconds(interval));</span>
<span class="nc" id="L1358">        return this;</span>
    }

    /**
     * Get the error threshold for a bookie to be quarantined.
     *
     * @return
     */
    public long getBookieErrorThresholdPerInterval() {
<span class="nc" id="L1367">        return getLong(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, 100);</span>
    }

    /**
     * Set the error threshold per interval ({@link #getBookieHealthCheckIntervalSeconds()}) for a bookie before it is
     * quarantined. Default is 100 errors per minute.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param thresholdPerInterval
     *
     * @return client configuration
     */
    public ClientConfiguration setBookieErrorThresholdPerInterval(long thresholdPerInterval) {
<span class="nc" id="L1383">        setProperty(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, thresholdPerInterval);</span>
<span class="nc" id="L1384">        return this;</span>
    }

    /**
     * Get the time for which a bookie will be quarantined.
     *
     * @return
     */
    public int getBookieQuarantineTimeSeconds() {
<span class="nc" id="L1393">        return getInt(BOOKIE_QUARANTINE_TIME_SECONDS, 1800);</span>
    }

    /**
     * Set the time for which a bookie will be quarantined. Default is 30 minutes.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param quarantineTime
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setBookieQuarantineTime(int quarantineTime, TimeUnit unit) {
<span class="nc" id="L1408">        setProperty(BOOKIE_QUARANTINE_TIME_SECONDS, unit.toSeconds(quarantineTime));</span>
<span class="nc" id="L1409">        return this;</span>
    }

    /**
     * Get the bookie quarantine ratio.
     *
     * @return
     */
    public double getBookieQuarantineRatio() {
<span class="nc" id="L1418">        return getDouble(BOOKIE_QUARANTINE_RATIO, 1.0);</span>
    }

    /**
     * set the bookie quarantine ratio. default is 1.0.
     *
     * @param ratio
     * @return client configuration
     */
    public ClientConfiguration setBookieQuarantineRatio(double ratio) {
<span class="nc" id="L1428">        setProperty(BOOKIE_QUARANTINE_RATIO, ratio);</span>
<span class="nc" id="L1429">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ClientConfiguration setNettyMaxFrameSizeBytes(int maxSize) {
<span class="nc" id="L1437">        super.setNettyMaxFrameSizeBytes(maxSize);</span>
<span class="nc" id="L1438">        return this;</span>
    }

    /**
     * Get the time interval between successive calls for bookie get info. Default is 24 hours.
     *
     * @return
     */
    public int getGetBookieInfoIntervalSeconds() {
<span class="nc" id="L1447">        return getInt(GET_BOOKIE_INFO_INTERVAL_SECONDS, 24 * 60 * 60);</span>
    }

    /**
     * Get the time interval between retries on unsuccessful bookie info request.  Default is
     * 60s.
     *
     * @return
     */
    public int getGetBookieInfoRetryIntervalSeconds() {
<span class="nc" id="L1457">        return getInt(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, 60);</span>
    }

    /**
     * Return whether disk weight based placement policy is enabled.
     * @return
     */
    public boolean getDiskWeightBasedPlacementEnabled() {
<span class="nc" id="L1465">        return getBoolean(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, false);</span>
    }

    /**
     * Returns the max multiple to use for nodes with very high weight.
     * @return max multiple
     */
    public int getBookieMaxWeightMultipleForWeightBasedPlacement() {
<span class="nc" id="L1473">        return getInt(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, 3);</span>
    }

    /**
     * Return the timeout value for getBookieInfo request.
     * @return
     */
    public int getBookieInfoTimeout() {
<span class="nc" id="L1481">        return getInteger(GET_BOOKIE_INFO_TIMEOUT_SECS, 5);</span>
    }

    /**
     * Return the timeout value for startTLS request.
     * @return
     */
    public int getStartTLSTimeout() {
<span class="nc" id="L1489">        return getInteger(START_TLS_TIMEOUT_SECS, 10);</span>
    }

    /**
     * Set whether or not disk weight based placement is enabled.
     *
     * @param isEnabled - boolean indicating enabled or not
     * @return client configuration
     */
    public ClientConfiguration setDiskWeightBasedPlacementEnabled(boolean isEnabled) {
<span class="nc" id="L1499">        setProperty(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, isEnabled);</span>
<span class="nc" id="L1500">        return this;</span>
    }

    /**
     * Set the time interval between successive polls for bookie get info.
     *
     * @param pollInterval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoIntervalSeconds(int pollInterval, TimeUnit unit) {
<span class="nc" id="L1511">        setProperty(GET_BOOKIE_INFO_INTERVAL_SECONDS, unit.toSeconds(pollInterval));</span>
<span class="nc" id="L1512">        return this;</span>
    }

    /**
     * Set the time interval between retries on unsuccessful GetInfo requests.
     *
     * @param interval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoRetryIntervalSeconds(int interval, TimeUnit unit) {
<span class="nc" id="L1523">        setProperty(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, unit.toSeconds(interval));</span>
<span class="nc" id="L1524">        return this;</span>
    }

    /**
     * Set the max multiple to use for nodes with very high weight.
     *
     * @param multiple
     * @return client configuration
     */
    public ClientConfiguration setBookieMaxWeightMultipleForWeightBasedPlacement(int multiple) {
<span class="nc" id="L1534">        setProperty(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, multiple);</span>
<span class="nc" id="L1535">        return this;</span>
    }

    /**
     * Set the timeout value in secs for the GET_BOOKIE_INFO request.
     *
     * @param timeoutSecs
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoTimeout(int timeoutSecs) {
<span class="nc" id="L1545">        setProperty(GET_BOOKIE_INFO_TIMEOUT_SECS, timeoutSecs);</span>
<span class="nc" id="L1546">        return this;</span>
    }

    /**
     * Set the timeout value in secs for the START_TLS request.
     * @param timeoutSecs
     * @return client configuration
     */
    public ClientConfiguration setStartTLSTimeout(int timeoutSecs) {
<span class="nc" id="L1555">        setProperty(START_TLS_TIMEOUT_SECS, timeoutSecs);</span>
<span class="nc" id="L1556">        return this;</span>
    }

    /**
     * Whether hostname verification enabled?
     *
     * @return true if hostname verification enabled, otherwise false.
     */
    public boolean getHostnameVerificationEnabled() {
<span class="nc" id="L1565">        return getBoolean(TLS_HOSTNAME_VERIFICATION_ENABLED, false);</span>
    }

    /**
     * Enable/Disable hostname verification for tls connection.
     *
     * @param enabled
     *            flag to enable/disable tls hostname verification.
     * @return client configuration.
     */
    public ClientConfiguration setHostnameVerificationEnabled(boolean enabled) {
<span class="nc" id="L1576">        setProperty(TLS_HOSTNAME_VERIFICATION_ENABLED, enabled);</span>
<span class="nc" id="L1577">        return this;</span>
    }

    /**
     * Set the client role.
     *
     * @param role defines how the client will act
     * @return client configuration
     */
    public ClientConfiguration setClientRole(String role) {
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L1588">            throw new NullPointerException();</span>
        }
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        switch (role) {</span>
            case CLIENT_ROLE_STANDARD:
            case CLIENT_ROLE_SYSTEM:
<span class="nc" id="L1593">                break;</span>
            default:
<span class="nc" id="L1595">                throw new IllegalArgumentException(&quot;invalid role &quot; + role);</span>
        }
<span class="nc" id="L1597">        setProperty(CLIENT_ROLE, role);</span>
<span class="nc" id="L1598">        return this;</span>
    }

    /**
     * Get the role of the client.
     *
     * @return the type of client
     */
    public String getClientRole() {
<span class="nc" id="L1607">        return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);</span>
    }

    /**
     * Get the keystore type for client. Default is JKS.
     *
     * @return
     */
    public String getTLSKeyStoreType() {
<span class="nc" id="L1616">        return getString(CLIENT_TLS_KEYSTORE_TYPE, getString(TLS_KEYSTORE_TYPE, &quot;JKS&quot;));</span>
    }


    /**
     * Set the keystore type for client.
     *
     * @return
     */
    public ClientConfiguration setTLSKeyStoreType(String arg) {
<span class="nc" id="L1626">        setProperty(TLS_KEYSTORE_TYPE, arg);</span>
<span class="nc" id="L1627">        return this;</span>
    }

    /**
     * Get the keystore path for the client.
     *
     * @return
     */
    public String getTLSKeyStore() {
<span class="nc" id="L1636">        return getString(CLIENT_TLS_KEYSTORE, getString(TLS_KEYSTORE, null));</span>
    }

    /**
     * Set the keystore path for the client.
     *
     * @return
     */
    public ClientConfiguration setTLSKeyStore(String arg) {
<span class="nc" id="L1645">        setProperty(TLS_KEYSTORE, arg);</span>
<span class="nc" id="L1646">        return this;</span>
    }

    /**
     * Get the path to file containing keystore password, if the client keystore is password protected. Default is null.
     *
     * @return
     */
    public String getTLSKeyStorePasswordPath() {
<span class="nc" id="L1655">        return getString(CLIENT_TLS_KEYSTORE_PASSWORD_PATH, getString(TLS_KEYSTORE_PASSWORD_PATH, null));</span>
    }

    /**
     * Set the path to file containing keystore password, if the client keystore is password protected.
     *
     * @return
     */
    public ClientConfiguration setTLSKeyStorePasswordPath(String arg) {
<span class="nc" id="L1664">        setProperty(TLS_KEYSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L1665">        return this;</span>
    }

    /**
     * Get the truststore type for client. Default is JKS.
     *
     * @return
     */
    public String getTLSTrustStoreType() {
<span class="nc" id="L1674">        return getString(CLIENT_TLS_TRUSTSTORE_TYPE, getString(TLS_TRUSTSTORE_TYPE, &quot;JKS&quot;));</span>
    }

    /**
     * Set the truststore type for client.
     *
     * @return
     */
    public ClientConfiguration setTLSTrustStoreType(String arg) {
<span class="nc" id="L1683">        setProperty(TLS_TRUSTSTORE_TYPE, arg);</span>
<span class="nc" id="L1684">        return this;</span>
    }

    /**
     * Get the truststore path for the client.
     *
     * @return
     */
    public String getTLSTrustStore() {
<span class="nc" id="L1693">        return getString(CLIENT_TLS_TRUSTSTORE, getString(TLS_TRUSTSTORE, null));</span>
    }

    /**
     * Set the truststore path for the client.
     *
     * @return
     */
    public ClientConfiguration setTLSTrustStore(String arg) {
<span class="nc" id="L1702">        setProperty(TLS_TRUSTSTORE, arg);</span>
<span class="nc" id="L1703">        return this;</span>
    }

    /**
     * Get the path to file containing truststore password, if the client truststore is password protected. Default is
     * null.
     *
     * @return
     */
    public String getTLSTrustStorePasswordPath() {
<span class="nc" id="L1713">        return getString(CLIENT_TLS_TRUSTSTORE_PASSWORD_PATH, getString(TLS_TRUSTSTORE_PASSWORD_PATH, null));</span>
    }

    /**
     * Set the path to file containing truststore password, if the client truststore is password protected.
     *
     * @return
     */
    public ClientConfiguration setTLSTrustStorePasswordPath(String arg) {
<span class="nc" id="L1722">        setProperty(TLS_TRUSTSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L1723">        return this;</span>
    }

    /**
     * Get the path to file containing TLS Certificate.
     *
     * @return
     */
    public String getTLSCertificatePath() {
<span class="nc" id="L1732">        return getString(TLS_CERTIFICATE_PATH, null);</span>
    }

    /**
     * Set the path to file containing TLS Certificate.
     *
     * @return
     */
    public ClientConfiguration setTLSCertificatePath(String arg) {
<span class="nc" id="L1741">        setProperty(TLS_CERTIFICATE_PATH, arg);</span>
<span class="nc" id="L1742">        return this;</span>
    }

    /**
     * Whether to allow opportunistic striping.
     *
     * @return true if opportunistic striping is enabled
     */
    public boolean getOpportunisticStriping() {
<span class="nc" id="L1751">        return getBoolean(OPPORTUNISTIC_STRIPING, false);</span>
    }

    /**
     * Enable/Disable opportunistic striping.
     * &lt;p&gt;
     * If set to true, when you are creating a ledger with a given
     * ensemble size, the system will automatically handle the
     * lack of enough bookies, reducing ensemble size up to
     * the write quorum size. This way in little clusters
     * you can try to use striping (ensemble size &gt; write quorum size)
     * in case that you have enough bookies up and running,
     * and degrade automatically to the minimum requested replication count.
     * &lt;/p&gt;
     *
     * @param enabled
     *          flag to enable/disable opportunistic striping.
     * @return client configuration.
     */
    public ClientConfiguration setOpportunisticStriping(boolean enabled) {
<span class="nc" id="L1771">        setProperty(OPPORTUNISTIC_STRIPING, enabled);</span>
<span class="nc" id="L1772">        return this;</span>
    }

    /**
     * Whether to delay ensemble change or not?
     *
     * @return true if to delay ensemble change, otherwise false.
     */
    public boolean getDelayEnsembleChange() {
<span class="nc" id="L1781">        return getBoolean(DELAY_ENSEMBLE_CHANGE, false);</span>
    }

    /**
     * Enable/Disable delaying ensemble change.
     * &lt;p&gt;
     * If set to true, ensemble change only happens when it can't meet
     * ack quorum requirement. If set to false, ensemble change happens
     * immediately when it received a failed write.
     * &lt;/p&gt;
     *
     * @param enabled
     *          flag to enable/disable delaying ensemble change.
     * @return client configuration.
     */
    public ClientConfiguration setDelayEnsembleChange(boolean enabled) {
<span class="nc" id="L1797">        setProperty(DELAY_ENSEMBLE_CHANGE, enabled);</span>
<span class="nc" id="L1798">        return this;</span>
    }

    /**
     * Whether to enable bookie address changes tracking.
     *
     * @return flag to enable/disable bookie address changes tracking
     */
    public boolean getEnableBookieAddressTracking() {
<span class="nc" id="L1807">        return getBoolean(FOLLOW_BOOKIE_ADDRESS_TRACKING, true);</span>
    }

    /**
     * Enable/Disable bookie address changes tracking.
     *
     * @param value
     *          flag to enable/disable bookie address changes tracking
     * @return client configuration.
     */
    public ClientConfiguration setEnableBookieAddressTracking(boolean value) {
<span class="nc" id="L1818">        setProperty(FOLLOW_BOOKIE_ADDRESS_TRACKING, value);</span>
<span class="nc" id="L1819">        return this;</span>
    }

    /**
     * Whether to enable bookie failure tracking.
     *
     * @return flag to enable/disable bookie failure tracking
     */
    public boolean getEnableBookieFailureTracking() {
<span class="nc" id="L1828">        return getBoolean(ENABLE_BOOKIE_FAILURE_TRACKING, true);</span>
    }

    /**
     * Enable/Disable bookie failure tracking.
     *
     * @param enabled
     *          flag to enable/disable bookie failure tracking
     * @return client configuration.
     */
    public ClientConfiguration setEnableBookieFailureTracking(boolean enabled) {
<span class="nc" id="L1839">        setProperty(ENABLE_BOOKIE_FAILURE_TRACKING, enabled);</span>
<span class="nc" id="L1840">        return this;</span>
    }

    /**
     * Get the bookie failure tracking expiration timeout.
     *
     * @return bookie failure tracking expiration timeout.
     */
    public int getBookieFailureHistoryExpirationMSec() {
<span class="nc" id="L1849">        return getInt(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, 60000);</span>
    }

    /**
     * Set the bookie failure tracking expiration timeout.
     *
     * @param expirationMSec
     *          bookie failure tracking expiration timeout.
     * @return client configuration.
     */
    public ClientConfiguration setBookieFailureHistoryExpirationMSec(int expirationMSec) {
<span class="nc" id="L1860">        setProperty(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, expirationMSec);</span>
<span class="nc" id="L1861">        return this;</span>
    }

    /**
     * Get the name of the dynamic feature that disables ensemble change.
     *
     * @return name of the dynamic feature that disables ensemble change
     */
    public String getDisableEnsembleChangeFeatureName() {
<span class="nc" id="L1870">        return getString(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, FEATURE_DISABLE_ENSEMBLE_CHANGE);</span>
    }

    /**
     * Set the name of the dynamic feature that disables ensemble change.
     *
     * @param disableEnsembleChangeFeatureName
     *          name of the dynamic feature that disables ensemble change
     * @return client configuration.
     */
    public ClientConfiguration setDisableEnsembleChangeFeatureName(String disableEnsembleChangeFeatureName) {
<span class="nc" id="L1881">        setProperty(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, disableEnsembleChangeFeatureName);</span>
<span class="nc" id="L1882">        return this;</span>
    }

    /**
     * Get the max allowed ensemble change number.
     *
     * @return value of MaxAllowedEnsembleChanges, default MAX_VALUE, indicating feature is disable.
     */
    public int getMaxAllowedEnsembleChanges() {
<span class="nc" id="L1891">        return getInt(MAX_ALLOWED_ENSEMBLE_CHANGES, Integer.MAX_VALUE);</span>
    }

    /**
     * Set the max allowed ensemble change number.
     *
     * @param num
     *          value of MaxAllowedEnsembleChanges
     * @return client configuration.
     */
    public ClientConfiguration setMaxAllowedEnsembleChanges(int num) {
<span class="nc" id="L1902">        setProperty(MAX_ALLOWED_ENSEMBLE_CHANGES, num);</span>
<span class="nc" id="L1903">        return this;</span>
    }

    /**
     * Option to use Netty Pooled ByteBufs.
     *
     * @deprecated see {@link BookKeeperBuilder#allocator(io.netty.buffer.ByteBufAllocator)}
     *
     * @return the value of the option
     */
    @Deprecated
    public boolean isNettyUsePooledBuffers() {
<span class="nc" id="L1915">        return getBoolean(NETTY_USE_POOLED_BUFFERS, true);</span>
    }

    /**
     * Enable/Disable the usage of Pooled Netty buffers. While using v2 wire protocol the application will be
     * responsible for releasing ByteBufs returned by BookKeeper.
     *
     * @param enabled
     *          if enabled BookKeeper will use default Pooled Netty Buffer allocator
     *
     * @deprecated see {@link BookKeeperBuilder#allocator(io.netty.buffer.ByteBufAllocator)}
     *
     * @see #setUseV2WireProtocol(boolean)
     * @see ByteBuf#release()
     * @see LedgerHandle#readEntries(long, long)
     */
    public ClientConfiguration setNettyUsePooledBuffers(boolean enabled) {
<span class="nc" id="L1932">        setProperty(NETTY_USE_POOLED_BUFFERS, enabled);</span>
<span class="nc" id="L1933">        return this;</span>
    }

    /**
     * Set registration manager class.
     *
     * @param regClientClass
     *            ClientClass
     * @deprecated since 4.7.0
     */
    @Deprecated
    public ClientConfiguration setRegistrationClientClass(
            Class&lt;? extends RegistrationClient&gt; regClientClass) {
<span class="nc" id="L1946">        setProperty(REGISTRATION_CLIENT_CLASS, regClientClass);</span>
<span class="nc" id="L1947">        return this;</span>
    }

    /**
     * Get Registration Client Class.
     *
     * @return registration manager class.
     * @deprecated since 4.7.0
     */
    @Deprecated
    public Class&lt;? extends RegistrationClient&gt; getRegistrationClientClass()
            throws ConfigurationException {
<span class="nc" id="L1959">        return ReflectionUtils.getClass(this, REGISTRATION_CLIENT_CLASS,</span>
                ZKRegistrationClient.class, RegistrationClient.class,
                DEFAULT_LOADER);
    }

    /**
     * Enable the client to use system time as the ledger creation time.
     *
     * &lt;p&gt;If this is enabled, the client will write a ctime field into the ledger metadata.
     * Otherwise, nothing will be written. The creation time of this ledger will be the ctime
     * of the metadata record in metadata store.
     *
     * @param enabled flag to enable/disable client using system time as the ledger creation time.
     */
    public ClientConfiguration setStoreSystemtimeAsLedgerCreationTime(boolean enabled) {
<span class="nc" id="L1974">        setProperty(STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME, enabled);</span>
<span class="nc" id="L1975">        return this;</span>
    }

    /**
     * Return the flag that indicates whether client is using system time as the ledger creation time when
     * creating ledgers.
     *
     * @return the flag that indicates whether client is using system time as the ledger creation time when
     *         creating ledgers.
     */
    public boolean getStoreSystemtimeAsLedgerCreationTime() {
<span class="nc" id="L1986">        return getBoolean(STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME, false);</span>
    }

    /**
     * Set the log frequency when a bookie is unavailable, in order to limit log filesize.
     *
     * @param throttleValue
     * @param unit
     * @return client configuration.
     */
    public ClientConfiguration setClientConnectBookieUnavailableLogThrottling(
            int throttleValue, TimeUnit unit) {
<span class="nc" id="L1998">        setProperty(CLIENT_CONNECT_BOOKIE_UNAVAILABLE_LOG_THROTTLING, unit.toMillis(throttleValue));</span>
<span class="nc" id="L1999">        return this;</span>
    }

    /**
     * Get the log frequency when a bookie is unavailable, in milliseconds.
     *
     * @return log frequency when a bookie is unavailable, in milliseconds.
     */
    public long getClientConnectBookieUnavailableLogThrottlingMs() {
<span class="nc" id="L2008">        return getLong(CLIENT_CONNECT_BOOKIE_UNAVAILABLE_LOG_THROTTLING, 5_000L);</span>
    }

    @Override
    protected ClientConfiguration getThis() {
<span class="nc" id="L2013">        return this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>